// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IMF_DeliverySchema.h"

namespace dsl
{
  // DeliverableType
  // 

  const DeliverableType::IdType& DeliverableType::
  getId () const
  {
    return this->Id_.get ();
  }

  DeliverableType::IdType& DeliverableType::
  getId ()
  {
    return this->Id_.get ();
  }

  void DeliverableType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void DeliverableType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->Id_.set (x);
  }

  const DeliverableType::LabelType& DeliverableType::
  getLabel () const
  {
    return this->Label_.get ();
  }

  DeliverableType::LabelType& DeliverableType::
  getLabel ()
  {
    return this->Label_.get ();
  }

  void DeliverableType::
  setLabel (const LabelType& x)
  {
    this->Label_.set (x);
  }

  void DeliverableType::
  setLabel (::std::auto_ptr< LabelType > x)
  {
    this->Label_.set (x);
  }

  const DeliverableType::CompositionPlaylistConstraintsType& DeliverableType::
  getCompositionPlaylistConstraints () const
  {
    return this->CompositionPlaylistConstraints_.get ();
  }

  DeliverableType::CompositionPlaylistConstraintsType& DeliverableType::
  getCompositionPlaylistConstraints ()
  {
    return this->CompositionPlaylistConstraints_.get ();
  }

  void DeliverableType::
  setCompositionPlaylistConstraints (const CompositionPlaylistConstraintsType& x)
  {
    this->CompositionPlaylistConstraints_.set (x);
  }

  void DeliverableType::
  setCompositionPlaylistConstraints (::std::auto_ptr< CompositionPlaylistConstraintsType > x)
  {
    this->CompositionPlaylistConstraints_.set (x);
  }


  // VirtualTrackType
  // 

  const VirtualTrackType::KindType& VirtualTrackType::
  getKind () const
  {
    return this->Kind_.get ();
  }

  VirtualTrackType::KindType& VirtualTrackType::
  getKind ()
  {
    return this->Kind_.get ();
  }

  void VirtualTrackType::
  setKind (const KindType& x)
  {
    this->Kind_.set (x);
  }

  void VirtualTrackType::
  setKind (::std::auto_ptr< KindType > x)
  {
    this->Kind_.set (x);
  }

  const VirtualTrackType::SoundfieldGroupConfigurationOptional& VirtualTrackType::
  getSoundfieldGroupConfiguration () const
  {
    return this->SoundfieldGroupConfiguration_;
  }

  VirtualTrackType::SoundfieldGroupConfigurationOptional& VirtualTrackType::
  getSoundfieldGroupConfiguration ()
  {
    return this->SoundfieldGroupConfiguration_;
  }

  void VirtualTrackType::
  setSoundfieldGroupConfiguration (const SoundfieldGroupConfigurationType& x)
  {
    this->SoundfieldGroupConfiguration_.set (x);
  }

  void VirtualTrackType::
  setSoundfieldGroupConfiguration (const SoundfieldGroupConfigurationOptional& x)
  {
    this->SoundfieldGroupConfiguration_ = x;
  }

  void VirtualTrackType::
  setSoundfieldGroupConfiguration (::std::auto_ptr< SoundfieldGroupConfigurationType > x)
  {
    this->SoundfieldGroupConfiguration_.set (x);
  }

  const VirtualTrackType::AudioChannelMappingOptional& VirtualTrackType::
  getAudioChannelMapping () const
  {
    return this->AudioChannelMapping_;
  }

  VirtualTrackType::AudioChannelMappingOptional& VirtualTrackType::
  getAudioChannelMapping ()
  {
    return this->AudioChannelMapping_;
  }

  void VirtualTrackType::
  setAudioChannelMapping (const AudioChannelMappingType& x)
  {
    this->AudioChannelMapping_.set (x);
  }

  void VirtualTrackType::
  setAudioChannelMapping (const AudioChannelMappingOptional& x)
  {
    this->AudioChannelMapping_ = x;
  }

  void VirtualTrackType::
  setAudioChannelMapping (::std::auto_ptr< AudioChannelMappingType > x)
  {
    this->AudioChannelMapping_.set (x);
  }

  const VirtualTrackType::EssenceEncodingType& VirtualTrackType::
  getEssenceEncoding () const
  {
    return this->EssenceEncoding_.get ();
  }

  VirtualTrackType::EssenceEncodingType& VirtualTrackType::
  getEssenceEncoding ()
  {
    return this->EssenceEncoding_.get ();
  }

  void VirtualTrackType::
  setEssenceEncoding (const EssenceEncodingType& x)
  {
    this->EssenceEncoding_.set (x);
  }

  void VirtualTrackType::
  setEssenceEncoding (::std::auto_ptr< EssenceEncodingType > x)
  {
    this->EssenceEncoding_.set (x);
  }

  const VirtualTrackType::EssenceEncodingConstraintListOptional& VirtualTrackType::
  getEssenceEncodingConstraintList () const
  {
    return this->EssenceEncodingConstraintList_;
  }

  VirtualTrackType::EssenceEncodingConstraintListOptional& VirtualTrackType::
  getEssenceEncodingConstraintList ()
  {
    return this->EssenceEncodingConstraintList_;
  }

  void VirtualTrackType::
  setEssenceEncodingConstraintList (const EssenceEncodingConstraintListType& x)
  {
    this->EssenceEncodingConstraintList_.set (x);
  }

  void VirtualTrackType::
  setEssenceEncodingConstraintList (const EssenceEncodingConstraintListOptional& x)
  {
    this->EssenceEncodingConstraintList_ = x;
  }

  void VirtualTrackType::
  setEssenceEncodingConstraintList (::std::auto_ptr< EssenceEncodingConstraintListType > x)
  {
    this->EssenceEncodingConstraintList_.set (x);
  }

  const VirtualTrackType::ColorimetryOptional& VirtualTrackType::
  getColorimetry () const
  {
    return this->Colorimetry_;
  }

  VirtualTrackType::ColorimetryOptional& VirtualTrackType::
  getColorimetry ()
  {
    return this->Colorimetry_;
  }

  void VirtualTrackType::
  setColorimetry (const ColorimetryType& x)
  {
    this->Colorimetry_.set (x);
  }

  void VirtualTrackType::
  setColorimetry (const ColorimetryOptional& x)
  {
    this->Colorimetry_ = x;
  }

  void VirtualTrackType::
  setColorimetry (::std::auto_ptr< ColorimetryType > x)
  {
    this->Colorimetry_.set (x);
  }

  const VirtualTrackType::SamplingOptional& VirtualTrackType::
  getSampling () const
  {
    return this->Sampling_;
  }

  VirtualTrackType::SamplingOptional& VirtualTrackType::
  getSampling ()
  {
    return this->Sampling_;
  }

  void VirtualTrackType::
  setSampling (const SamplingType& x)
  {
    this->Sampling_.set (x);
  }

  void VirtualTrackType::
  setSampling (const SamplingOptional& x)
  {
    this->Sampling_ = x;
  }

  void VirtualTrackType::
  setSampling (::std::auto_ptr< SamplingType > x)
  {
    this->Sampling_.set (x);
  }

  const VirtualTrackType::QuantizationOptional& VirtualTrackType::
  getQuantization () const
  {
    return this->Quantization_;
  }

  VirtualTrackType::QuantizationOptional& VirtualTrackType::
  getQuantization ()
  {
    return this->Quantization_;
  }

  void VirtualTrackType::
  setQuantization (const QuantizationType& x)
  {
    this->Quantization_.set (x);
  }

  void VirtualTrackType::
  setQuantization (const QuantizationOptional& x)
  {
    this->Quantization_ = x;
  }

  void VirtualTrackType::
  setQuantization (::std::auto_ptr< QuantizationType > x)
  {
    this->Quantization_.set (x);
  }

  const VirtualTrackType::FrameStructureOptional& VirtualTrackType::
  getFrameStructure () const
  {
    return this->FrameStructure_;
  }

  VirtualTrackType::FrameStructureOptional& VirtualTrackType::
  getFrameStructure ()
  {
    return this->FrameStructure_;
  }

  void VirtualTrackType::
  setFrameStructure (const FrameStructureType& x)
  {
    this->FrameStructure_.set (x);
  }

  void VirtualTrackType::
  setFrameStructure (const FrameStructureOptional& x)
  {
    this->FrameStructure_ = x;
  }

  void VirtualTrackType::
  setFrameStructure (::std::auto_ptr< FrameStructureType > x)
  {
    this->FrameStructure_.set (x);
  }

  const VirtualTrackType::StereoscopyOptional& VirtualTrackType::
  getStereoscopy () const
  {
    return this->Stereoscopy_;
  }

  VirtualTrackType::StereoscopyOptional& VirtualTrackType::
  getStereoscopy ()
  {
    return this->Stereoscopy_;
  }

  void VirtualTrackType::
  setStereoscopy (const StereoscopyType& x)
  {
    this->Stereoscopy_.set (x);
  }

  void VirtualTrackType::
  setStereoscopy (const StereoscopyOptional& x)
  {
    this->Stereoscopy_ = x;
  }

  void VirtualTrackType::
  setStereoscopy (::std::auto_ptr< StereoscopyType > x)
  {
    this->Stereoscopy_.set (x);
  }

  const VirtualTrackType::ColorComponentsOptional& VirtualTrackType::
  getColorComponents () const
  {
    return this->ColorComponents_;
  }

  VirtualTrackType::ColorComponentsOptional& VirtualTrackType::
  getColorComponents ()
  {
    return this->ColorComponents_;
  }

  void VirtualTrackType::
  setColorComponents (const ColorComponentsType& x)
  {
    this->ColorComponents_.set (x);
  }

  void VirtualTrackType::
  setColorComponents (const ColorComponentsOptional& x)
  {
    this->ColorComponents_ = x;
  }

  void VirtualTrackType::
  setColorComponents (::std::auto_ptr< ColorComponentsType > x)
  {
    this->ColorComponents_.set (x);
  }

  const VirtualTrackType::PixelBitDepthListOptional& VirtualTrackType::
  getPixelBitDepthList () const
  {
    return this->PixelBitDepthList_;
  }

  VirtualTrackType::PixelBitDepthListOptional& VirtualTrackType::
  getPixelBitDepthList ()
  {
    return this->PixelBitDepthList_;
  }

  void VirtualTrackType::
  setPixelBitDepthList (const PixelBitDepthListType& x)
  {
    this->PixelBitDepthList_.set (x);
  }

  void VirtualTrackType::
  setPixelBitDepthList (const PixelBitDepthListOptional& x)
  {
    this->PixelBitDepthList_ = x;
  }

  void VirtualTrackType::
  setPixelBitDepthList (::std::auto_ptr< PixelBitDepthListType > x)
  {
    this->PixelBitDepthList_.set (x);
  }

  const VirtualTrackType::ImageFrameWidthListOptional& VirtualTrackType::
  getImageFrameWidthList () const
  {
    return this->ImageFrameWidthList_;
  }

  VirtualTrackType::ImageFrameWidthListOptional& VirtualTrackType::
  getImageFrameWidthList ()
  {
    return this->ImageFrameWidthList_;
  }

  void VirtualTrackType::
  setImageFrameWidthList (const ImageFrameWidthListType& x)
  {
    this->ImageFrameWidthList_.set (x);
  }

  void VirtualTrackType::
  setImageFrameWidthList (const ImageFrameWidthListOptional& x)
  {
    this->ImageFrameWidthList_ = x;
  }

  void VirtualTrackType::
  setImageFrameWidthList (::std::auto_ptr< ImageFrameWidthListType > x)
  {
    this->ImageFrameWidthList_.set (x);
  }

  const VirtualTrackType::ImageFrameHeightListOptional& VirtualTrackType::
  getImageFrameHeightList () const
  {
    return this->ImageFrameHeightList_;
  }

  VirtualTrackType::ImageFrameHeightListOptional& VirtualTrackType::
  getImageFrameHeightList ()
  {
    return this->ImageFrameHeightList_;
  }

  void VirtualTrackType::
  setImageFrameHeightList (const ImageFrameHeightListType& x)
  {
    this->ImageFrameHeightList_.set (x);
  }

  void VirtualTrackType::
  setImageFrameHeightList (const ImageFrameHeightListOptional& x)
  {
    this->ImageFrameHeightList_ = x;
  }

  void VirtualTrackType::
  setImageFrameHeightList (::std::auto_ptr< ImageFrameHeightListType > x)
  {
    this->ImageFrameHeightList_.set (x);
  }

  const VirtualTrackType::FrameRateListOptional& VirtualTrackType::
  getFrameRateList () const
  {
    return this->FrameRateList_;
  }

  VirtualTrackType::FrameRateListOptional& VirtualTrackType::
  getFrameRateList ()
  {
    return this->FrameRateList_;
  }

  void VirtualTrackType::
  setFrameRateList (const FrameRateListType& x)
  {
    this->FrameRateList_.set (x);
  }

  void VirtualTrackType::
  setFrameRateList (const FrameRateListOptional& x)
  {
    this->FrameRateList_ = x;
  }

  void VirtualTrackType::
  setFrameRateList (::std::auto_ptr< FrameRateListType > x)
  {
    this->FrameRateList_.set (x);
  }

  const VirtualTrackType::SampleRateListOptional& VirtualTrackType::
  getSampleRateList () const
  {
    return this->SampleRateList_;
  }

  VirtualTrackType::SampleRateListOptional& VirtualTrackType::
  getSampleRateList ()
  {
    return this->SampleRateList_;
  }

  void VirtualTrackType::
  setSampleRateList (const SampleRateListType& x)
  {
    this->SampleRateList_.set (x);
  }

  void VirtualTrackType::
  setSampleRateList (const SampleRateListOptional& x)
  {
    this->SampleRateList_ = x;
  }

  void VirtualTrackType::
  setSampleRateList (::std::auto_ptr< SampleRateListType > x)
  {
    this->SampleRateList_.set (x);
  }

  const VirtualTrackType::TimelineComplexitySequence& VirtualTrackType::
  getTimelineComplexity () const
  {
    return this->TimelineComplexity_;
  }

  VirtualTrackType::TimelineComplexitySequence& VirtualTrackType::
  getTimelineComplexity ()
  {
    return this->TimelineComplexity_;
  }

  void VirtualTrackType::
  setTimelineComplexity (const TimelineComplexitySequence& s)
  {
    this->TimelineComplexity_ = s;
  }

  const VirtualTrackType::ReferenceCardinalityOptional& VirtualTrackType::
  getReferenceCardinality () const
  {
    return this->ReferenceCardinality_;
  }

  VirtualTrackType::ReferenceCardinalityOptional& VirtualTrackType::
  getReferenceCardinality ()
  {
    return this->ReferenceCardinality_;
  }

  void VirtualTrackType::
  setReferenceCardinality (const ReferenceCardinalityType& x)
  {
    this->ReferenceCardinality_.set (x);
  }

  void VirtualTrackType::
  setReferenceCardinality (const ReferenceCardinalityOptional& x)
  {
    this->ReferenceCardinality_ = x;
  }

  void VirtualTrackType::
  setReferenceCardinality (::std::auto_ptr< ReferenceCardinalityType > x)
  {
    this->ReferenceCardinality_.set (x);
  }

  const VirtualTrackType::NamespaceOptional& VirtualTrackType::
  getNamespace () const
  {
    return this->namespace__;
  }

  VirtualTrackType::NamespaceOptional& VirtualTrackType::
  getNamespace ()
  {
    return this->namespace__;
  }

  void VirtualTrackType::
  setNamespace (const NamespaceType& x)
  {
    this->namespace__.set (x);
  }

  void VirtualTrackType::
  setNamespace (const NamespaceOptional& x)
  {
    this->namespace__ = x;
  }

  void VirtualTrackType::
  setNamespace (::std::auto_ptr< NamespaceType > x)
  {
    this->namespace__.set (x);
  }


  // CardinalityType
  // 

  const CardinalityType::MinItemType& CardinalityType::
  getMinItem () const
  {
    return this->MinItem_.get ();
  }

  CardinalityType::MinItemType& CardinalityType::
  getMinItem ()
  {
    return this->MinItem_.get ();
  }

  void CardinalityType::
  setMinItem (const MinItemType& x)
  {
    this->MinItem_.set (x);
  }

  void CardinalityType::
  setMinItem (::std::auto_ptr< MinItemType > x)
  {
    this->MinItem_.set (x);
  }

  const CardinalityType::MaxItemType& CardinalityType::
  getMaxItem () const
  {
    return this->MaxItem_.get ();
  }

  CardinalityType::MaxItemType& CardinalityType::
  getMaxItem ()
  {
    return this->MaxItem_.get ();
  }

  void CardinalityType::
  setMaxItem (const MaxItemType& x)
  {
    this->MaxItem_.set (x);
  }

  void CardinalityType::
  setMaxItem (::std::auto_ptr< MaxItemType > x)
  {
    this->MaxItem_.set (x);
  }


  // DeliverySpecificationList
  // 

  const DeliverySpecificationList::IdType& DeliverySpecificationList::
  getId () const
  {
    return this->Id_.get ();
  }

  DeliverySpecificationList::IdType& DeliverySpecificationList::
  getId ()
  {
    return this->Id_.get ();
  }

  void DeliverySpecificationList::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void DeliverySpecificationList::
  setId (::std::auto_ptr< IdType > x)
  {
    this->Id_.set (x);
  }

  const DeliverySpecificationList::AnnotationTextOptional& DeliverySpecificationList::
  getAnnotationText () const
  {
    return this->AnnotationText_;
  }

  DeliverySpecificationList::AnnotationTextOptional& DeliverySpecificationList::
  getAnnotationText ()
  {
    return this->AnnotationText_;
  }

  void DeliverySpecificationList::
  setAnnotationText (const AnnotationTextType& x)
  {
    this->AnnotationText_.set (x);
  }

  void DeliverySpecificationList::
  setAnnotationText (const AnnotationTextOptional& x)
  {
    this->AnnotationText_ = x;
  }

  void DeliverySpecificationList::
  setAnnotationText (::std::auto_ptr< AnnotationTextType > x)
  {
    this->AnnotationText_.set (x);
  }

  const DeliverySpecificationList::IssueDateType& DeliverySpecificationList::
  getIssueDate () const
  {
    return this->IssueDate_.get ();
  }

  DeliverySpecificationList::IssueDateType& DeliverySpecificationList::
  getIssueDate ()
  {
    return this->IssueDate_.get ();
  }

  void DeliverySpecificationList::
  setIssueDate (const IssueDateType& x)
  {
    this->IssueDate_.set (x);
  }

  void DeliverySpecificationList::
  setIssueDate (::std::auto_ptr< IssueDateType > x)
  {
    this->IssueDate_.set (x);
  }

  const DeliverySpecificationList::IssuerOptional& DeliverySpecificationList::
  getIssuer () const
  {
    return this->Issuer_;
  }

  DeliverySpecificationList::IssuerOptional& DeliverySpecificationList::
  getIssuer ()
  {
    return this->Issuer_;
  }

  void DeliverySpecificationList::
  setIssuer (const IssuerType& x)
  {
    this->Issuer_.set (x);
  }

  void DeliverySpecificationList::
  setIssuer (const IssuerOptional& x)
  {
    this->Issuer_ = x;
  }

  void DeliverySpecificationList::
  setIssuer (::std::auto_ptr< IssuerType > x)
  {
    this->Issuer_.set (x);
  }

  const DeliverySpecificationList::CreatorOptional& DeliverySpecificationList::
  getCreator () const
  {
    return this->Creator_;
  }

  DeliverySpecificationList::CreatorOptional& DeliverySpecificationList::
  getCreator ()
  {
    return this->Creator_;
  }

  void DeliverySpecificationList::
  setCreator (const CreatorType& x)
  {
    this->Creator_.set (x);
  }

  void DeliverySpecificationList::
  setCreator (const CreatorOptional& x)
  {
    this->Creator_ = x;
  }

  void DeliverySpecificationList::
  setCreator (::std::auto_ptr< CreatorType > x)
  {
    this->Creator_.set (x);
  }

  const DeliverySpecificationList::DeliverableListType& DeliverySpecificationList::
  getDeliverableList () const
  {
    return this->DeliverableList_.get ();
  }

  DeliverySpecificationList::DeliverableListType& DeliverySpecificationList::
  getDeliverableList ()
  {
    return this->DeliverableList_.get ();
  }

  void DeliverySpecificationList::
  setDeliverableList (const DeliverableListType& x)
  {
    this->DeliverableList_.set (x);
  }

  void DeliverySpecificationList::
  setDeliverableList (::std::auto_ptr< DeliverableListType > x)
  {
    this->DeliverableList_.set (x);
  }


  // DeliverableType_LabelType
  // 


  // DeliverableType_CompositionPlaylistConstraintsType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType::OwnerIdType& DeliverableType_CompositionPlaylistConstraintsType::
  getOwnerId () const
  {
    return this->OwnerId_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType::OwnerIdType& DeliverableType_CompositionPlaylistConstraintsType::
  getOwnerId ()
  {
    return this->OwnerId_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setOwnerId (const OwnerIdType& x)
  {
    this->OwnerId_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setOwnerId (::std::auto_ptr< OwnerIdType > x)
  {
    this->OwnerId_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationListOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentificationList () const
  {
    return this->ApplicationIdentificationList_;
  }

  DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationListOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentificationList ()
  {
    return this->ApplicationIdentificationList_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentificationList (const ApplicationIdentificationListType& x)
  {
    this->ApplicationIdentificationList_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentificationList (const ApplicationIdentificationListOptional& x)
  {
    this->ApplicationIdentificationList_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentificationList (::std::auto_ptr< ApplicationIdentificationListType > x)
  {
    this->ApplicationIdentificationList_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentification () const
  {
    return this->ApplicationIdentification_;
  }

  DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentification ()
  {
    return this->ApplicationIdentification_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentification (const ApplicationIdentificationType& x)
  {
    this->ApplicationIdentification_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentification (const ApplicationIdentificationOptional& x)
  {
    this->ApplicationIdentification_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentification (::std::auto_ptr< ApplicationIdentificationType > x)
  {
    this->ApplicationIdentification_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::VirtualTrackListType& DeliverableType_CompositionPlaylistConstraintsType::
  getVirtualTrackList () const
  {
    return this->VirtualTrackList_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType::VirtualTrackListType& DeliverableType_CompositionPlaylistConstraintsType::
  getVirtualTrackList ()
  {
    return this->VirtualTrackList_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setVirtualTrackList (const VirtualTrackListType& x)
  {
    this->VirtualTrackList_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setVirtualTrackList (::std::auto_ptr< VirtualTrackListType > x)
  {
    this->VirtualTrackList_.set (x);
  }


  // VirtualTrackType_SoundfieldGroupConfigurationType
  // 

  const VirtualTrackType_SoundfieldGroupConfigurationType::MCATagSymbolType& VirtualTrackType_SoundfieldGroupConfigurationType::
  getMCATagSymbol () const
  {
    return this->MCATagSymbol_.get ();
  }

  VirtualTrackType_SoundfieldGroupConfigurationType::MCATagSymbolType& VirtualTrackType_SoundfieldGroupConfigurationType::
  getMCATagSymbol ()
  {
    return this->MCATagSymbol_.get ();
  }

  void VirtualTrackType_SoundfieldGroupConfigurationType::
  setMCATagSymbol (const MCATagSymbolType& x)
  {
    this->MCATagSymbol_.set (x);
  }

  void VirtualTrackType_SoundfieldGroupConfigurationType::
  setMCATagSymbol (::std::auto_ptr< MCATagSymbolType > x)
  {
    this->MCATagSymbol_.set (x);
  }


  // VirtualTrackType_AudioChannelMappingType
  // 

  const VirtualTrackType_AudioChannelMappingType::AudioChannelSequence& VirtualTrackType_AudioChannelMappingType::
  getAudioChannel () const
  {
    return this->AudioChannel_;
  }

  VirtualTrackType_AudioChannelMappingType::AudioChannelSequence& VirtualTrackType_AudioChannelMappingType::
  getAudioChannel ()
  {
    return this->AudioChannel_;
  }

  void VirtualTrackType_AudioChannelMappingType::
  setAudioChannel (const AudioChannelSequence& s)
  {
    this->AudioChannel_ = s;
  }


  // VirtualTrackType_EssenceEncodingConstraintListType
  // 

  const VirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintSequence& VirtualTrackType_EssenceEncodingConstraintListType::
  getEssenceEncodingConstraint () const
  {
    return this->EssenceEncodingConstraint_;
  }

  VirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintSequence& VirtualTrackType_EssenceEncodingConstraintListType::
  getEssenceEncodingConstraint ()
  {
    return this->EssenceEncodingConstraint_;
  }

  void VirtualTrackType_EssenceEncodingConstraintListType::
  setEssenceEncodingConstraint (const EssenceEncodingConstraintSequence& s)
  {
    this->EssenceEncodingConstraint_ = s;
  }

  const VirtualTrackType_EssenceEncodingConstraintListType::ScopeType& VirtualTrackType_EssenceEncodingConstraintListType::
  getScope () const
  {
    return this->scope_.get ();
  }

  VirtualTrackType_EssenceEncodingConstraintListType::ScopeType& VirtualTrackType_EssenceEncodingConstraintListType::
  getScope ()
  {
    return this->scope_.get ();
  }

  void VirtualTrackType_EssenceEncodingConstraintListType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void VirtualTrackType_EssenceEncodingConstraintListType::
  setScope (::std::auto_ptr< ScopeType > x)
  {
    this->scope_.set (x);
  }


  // VirtualTrackType_ColorComponentsType
  // 


  // VirtualTrackType_PixelBitDepthListType
  // 

  const VirtualTrackType_PixelBitDepthListType::PixelBitDepthSequence& VirtualTrackType_PixelBitDepthListType::
  getPixelBitDepth () const
  {
    return this->PixelBitDepth_;
  }

  VirtualTrackType_PixelBitDepthListType::PixelBitDepthSequence& VirtualTrackType_PixelBitDepthListType::
  getPixelBitDepth ()
  {
    return this->PixelBitDepth_;
  }

  void VirtualTrackType_PixelBitDepthListType::
  setPixelBitDepth (const PixelBitDepthSequence& s)
  {
    this->PixelBitDepth_ = s;
  }


  // VirtualTrackType_ImageFrameWidthListType
  // 

  const VirtualTrackType_ImageFrameWidthListType::ImageFrameWidthSequence& VirtualTrackType_ImageFrameWidthListType::
  getImageFrameWidth () const
  {
    return this->ImageFrameWidth_;
  }

  VirtualTrackType_ImageFrameWidthListType::ImageFrameWidthSequence& VirtualTrackType_ImageFrameWidthListType::
  getImageFrameWidth ()
  {
    return this->ImageFrameWidth_;
  }

  void VirtualTrackType_ImageFrameWidthListType::
  setImageFrameWidth (const ImageFrameWidthSequence& s)
  {
    this->ImageFrameWidth_ = s;
  }


  // VirtualTrackType_ImageFrameHeightListType
  // 

  const VirtualTrackType_ImageFrameHeightListType::ImageFrameHeightSequence& VirtualTrackType_ImageFrameHeightListType::
  getImageFrameHeight () const
  {
    return this->ImageFrameHeight_;
  }

  VirtualTrackType_ImageFrameHeightListType::ImageFrameHeightSequence& VirtualTrackType_ImageFrameHeightListType::
  getImageFrameHeight ()
  {
    return this->ImageFrameHeight_;
  }

  void VirtualTrackType_ImageFrameHeightListType::
  setImageFrameHeight (const ImageFrameHeightSequence& s)
  {
    this->ImageFrameHeight_ = s;
  }


  // VirtualTrackType_FrameRateListType
  // 

  const VirtualTrackType_FrameRateListType::FrameRateSequence& VirtualTrackType_FrameRateListType::
  getFrameRate () const
  {
    return this->FrameRate_;
  }

  VirtualTrackType_FrameRateListType::FrameRateSequence& VirtualTrackType_FrameRateListType::
  getFrameRate ()
  {
    return this->FrameRate_;
  }

  void VirtualTrackType_FrameRateListType::
  setFrameRate (const FrameRateSequence& s)
  {
    this->FrameRate_ = s;
  }


  // VirtualTrackType_SampleRateListType
  // 

  const VirtualTrackType_SampleRateListType::SampleRateSequence& VirtualTrackType_SampleRateListType::
  getSampleRate () const
  {
    return this->SampleRate_;
  }

  VirtualTrackType_SampleRateListType::SampleRateSequence& VirtualTrackType_SampleRateListType::
  getSampleRate ()
  {
    return this->SampleRate_;
  }

  void VirtualTrackType_SampleRateListType::
  setSampleRate (const SampleRateSequence& s)
  {
    this->SampleRate_ = s;
  }


  // VirtualTrackType_TimelineComplexityType
  // 

  const VirtualTrackType_TimelineComplexityType::SequenceCardinalityOptional& VirtualTrackType_TimelineComplexityType::
  getSequenceCardinality () const
  {
    return this->SequenceCardinality_;
  }

  VirtualTrackType_TimelineComplexityType::SequenceCardinalityOptional& VirtualTrackType_TimelineComplexityType::
  getSequenceCardinality ()
  {
    return this->SequenceCardinality_;
  }

  void VirtualTrackType_TimelineComplexityType::
  setSequenceCardinality (const SequenceCardinalityType& x)
  {
    this->SequenceCardinality_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType::
  setSequenceCardinality (const SequenceCardinalityOptional& x)
  {
    this->SequenceCardinality_ = x;
  }

  void VirtualTrackType_TimelineComplexityType::
  setSequenceCardinality (::std::auto_ptr< SequenceCardinalityType > x)
  {
    this->SequenceCardinality_.set (x);
  }

  const VirtualTrackType_TimelineComplexityType::ResourceCardinalityOptional& VirtualTrackType_TimelineComplexityType::
  getResourceCardinality () const
  {
    return this->ResourceCardinality_;
  }

  VirtualTrackType_TimelineComplexityType::ResourceCardinalityOptional& VirtualTrackType_TimelineComplexityType::
  getResourceCardinality ()
  {
    return this->ResourceCardinality_;
  }

  void VirtualTrackType_TimelineComplexityType::
  setResourceCardinality (const ResourceCardinalityType& x)
  {
    this->ResourceCardinality_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType::
  setResourceCardinality (const ResourceCardinalityOptional& x)
  {
    this->ResourceCardinality_ = x;
  }

  void VirtualTrackType_TimelineComplexityType::
  setResourceCardinality (::std::auto_ptr< ResourceCardinalityType > x)
  {
    this->ResourceCardinality_.set (x);
  }

  const VirtualTrackType_TimelineComplexityType::SequenceType& VirtualTrackType_TimelineComplexityType::
  getSequence () const
  {
    return this->Sequence_.get ();
  }

  VirtualTrackType_TimelineComplexityType::SequenceType& VirtualTrackType_TimelineComplexityType::
  getSequence ()
  {
    return this->Sequence_.get ();
  }

  void VirtualTrackType_TimelineComplexityType::
  setSequence (const SequenceType& x)
  {
    this->Sequence_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType::
  setSequence (::std::auto_ptr< SequenceType > x)
  {
    this->Sequence_.set (x);
  }

  const VirtualTrackType_TimelineComplexityType::TypeType& VirtualTrackType_TimelineComplexityType::
  getType () const
  {
    return this->type_.get ();
  }

  VirtualTrackType_TimelineComplexityType::TypeType& VirtualTrackType_TimelineComplexityType::
  getType ()
  {
    return this->type_.get ();
  }

  void VirtualTrackType_TimelineComplexityType::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType::
  setType (::std::auto_ptr< TypeType > x)
  {
    this->type_.set (x);
  }


  // VirtualTrackType_ReferenceCardinalityType
  // 

  const VirtualTrackType_ReferenceCardinalityType::SequenceType& VirtualTrackType_ReferenceCardinalityType::
  getSequence () const
  {
    return this->Sequence_.get ();
  }

  VirtualTrackType_ReferenceCardinalityType::SequenceType& VirtualTrackType_ReferenceCardinalityType::
  getSequence ()
  {
    return this->Sequence_.get ();
  }

  void VirtualTrackType_ReferenceCardinalityType::
  setSequence (const SequenceType& x)
  {
    this->Sequence_.set (x);
  }

  void VirtualTrackType_ReferenceCardinalityType::
  setSequence (::std::auto_ptr< SequenceType > x)
  {
    this->Sequence_.set (x);
  }


  // VirtualTrackType_namespaceType
  // 


  // CardinalityType_MinItemType
  // 


  // CardinalityType_MaxItemType
  // 


  // DeliverySpecificationList_DeliverableListType
  // 

  const DeliverySpecificationList_DeliverableListType::DeliverableSequence& DeliverySpecificationList_DeliverableListType::
  getDeliverable () const
  {
    return this->Deliverable_;
  }

  DeliverySpecificationList_DeliverableListType::DeliverableSequence& DeliverySpecificationList_DeliverableListType::
  getDeliverable ()
  {
    return this->Deliverable_;
  }

  void DeliverySpecificationList_DeliverableListType::
  setDeliverable (const DeliverableSequence& s)
  {
    this->Deliverable_ = s;
  }


  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::MatchTypeType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getMatchType () const
  {
    return this->MatchType_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::MatchTypeType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getMatchType ()
  {
    return this->MatchType_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setMatchType (const MatchTypeType& x)
  {
    this->MatchType_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setMatchType (::std::auto_ptr< MatchTypeType > x)
  {
    this->MatchType_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::ValueListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getValueList () const
  {
    return this->ValueList_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::ValueListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getValueList ()
  {
    return this->ValueList_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setValueList (const ValueListType& x)
  {
    this->ValueList_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setValueList (::std::auto_ptr< ValueListType > x)
  {
    this->ValueList_.set (x);
  }


  // DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::VirtualTrackSequence& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getVirtualTrack () const
  {
    return this->VirtualTrack_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::VirtualTrackSequence& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getVirtualTrack ()
  {
    return this->VirtualTrack_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setVirtualTrack (const VirtualTrackSequence& s)
  {
    this->VirtualTrack_ = s;
  }


  // VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType
  // 


  // VirtualTrackType_AudioChannelMappingType_AudioChannelType
  // 

  const VirtualTrackType_AudioChannelMappingType_AudioChannelType::MCATagSymbolType& VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  getMCATagSymbol () const
  {
    return this->MCATagSymbol_.get ();
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType::MCATagSymbolType& VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  getMCATagSymbol ()
  {
    return this->MCATagSymbol_.get ();
  }

  void VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  setMCATagSymbol (const MCATagSymbolType& x)
  {
    this->MCATagSymbol_.set (x);
  }

  void VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  setMCATagSymbol (::std::auto_ptr< MCATagSymbolType > x)
  {
    this->MCATagSymbol_.set (x);
  }


  // VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType
  // 

  const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::NameType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getName () const
  {
    return this->Name_.get ();
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::NameType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getName ()
  {
    return this->Name_.get ();
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setName (const NameType& x)
  {
    this->Name_.set (x);
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->Name_.set (x);
  }

  const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::PropertyListType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getPropertyList () const
  {
    return this->PropertyList_.get ();
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::PropertyListType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getPropertyList ()
  {
    return this->PropertyList_.get ();
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setPropertyList (const PropertyListType& x)
  {
    this->PropertyList_.set (x);
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setPropertyList (::std::auto_ptr< PropertyListType > x)
  {
    this->PropertyList_.set (x);
  }


  // VirtualTrackType_TimelineComplexityType_SequenceType
  // 

  const VirtualTrackType_TimelineComplexityType_SequenceType::CardinalityOptional& VirtualTrackType_TimelineComplexityType_SequenceType::
  getCardinality () const
  {
    return this->Cardinality_;
  }

  VirtualTrackType_TimelineComplexityType_SequenceType::CardinalityOptional& VirtualTrackType_TimelineComplexityType_SequenceType::
  getCardinality ()
  {
    return this->Cardinality_;
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType::
  setCardinality (const CardinalityType& x)
  {
    this->Cardinality_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType::
  setCardinality (const CardinalityOptional& x)
  {
    this->Cardinality_ = x;
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType::
  setCardinality (::std::auto_ptr< CardinalityType > x)
  {
    this->Cardinality_.set (x);
  }

  const VirtualTrackType_TimelineComplexityType_SequenceType::ResourceType& VirtualTrackType_TimelineComplexityType_SequenceType::
  getResource () const
  {
    return this->Resource_.get ();
  }

  VirtualTrackType_TimelineComplexityType_SequenceType::ResourceType& VirtualTrackType_TimelineComplexityType_SequenceType::
  getResource ()
  {
    return this->Resource_.get ();
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType::
  setResource (const ResourceType& x)
  {
    this->Resource_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType::
  setResource (::std::auto_ptr< ResourceType > x)
  {
    this->Resource_.set (x);
  }


  // VirtualTrackType_TimelineComplexityType_typeType
  // 


  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType
  // 


  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationSequence& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  getApplicationIdentification () const
  {
    return this->ApplicationIdentification_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationSequence& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  getApplicationIdentification ()
  {
    return this->ApplicationIdentification_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  setApplicationIdentification (const ApplicationIdentificationSequence& s)
  {
    this->ApplicationIdentification_ = s;
  }


  // VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType
  // 


  // VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType
  // 

  const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertySequence& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  getProperty () const
  {
    return this->Property_;
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertySequence& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  getProperty ()
  {
    return this->Property_;
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  setProperty (const PropertySequence& s)
  {
    this->Property_ = s;
  }


  // VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType
  // 

  const VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::CardinalityOptional& VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  getCardinality () const
  {
    return this->Cardinality_;
  }

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::CardinalityOptional& VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  getCardinality ()
  {
    return this->Cardinality_;
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  setCardinality (const CardinalityType& x)
  {
    this->Cardinality_.set (x);
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  setCardinality (const CardinalityOptional& x)
  {
    this->Cardinality_ = x;
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  setCardinality (::std::auto_ptr< CardinalityType > x)
  {
    this->Cardinality_.set (x);
  }


  // VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType
  // 

  const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::NameType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getName () const
  {
    return this->Name_.get ();
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::NameType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getName ()
  {
    return this->Name_.get ();
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setName (const NameType& x)
  {
    this->Name_.set (x);
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->Name_.set (x);
  }

  const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::ValueType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getValue () const
  {
    return this->value_.get ();
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::ValueType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getValue ()
  {
    return this->value_.get ();
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setValue (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace dsl
{
  // DeliverableType
  //

  DeliverableType::
  DeliverableType (const IdType& Id,
                   const LabelType& Label,
                   const CompositionPlaylistConstraintsType& CompositionPlaylistConstraints)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Label_ (Label, this),
    CompositionPlaylistConstraints_ (CompositionPlaylistConstraints, this)
  {
  }

  DeliverableType::
  DeliverableType (const IdType& Id,
                   const LabelType& Label,
                   ::std::auto_ptr< CompositionPlaylistConstraintsType > CompositionPlaylistConstraints)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Label_ (Label, this),
    CompositionPlaylistConstraints_ (CompositionPlaylistConstraints, this)
  {
  }

  DeliverableType::
  DeliverableType (const DeliverableType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    Label_ (x.Label_, f, this),
    CompositionPlaylistConstraints_ (x.CompositionPlaylistConstraints_, f, this)
  {
  }

  DeliverableType::
  DeliverableType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    Label_ (this),
    CompositionPlaylistConstraints_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (r);
          continue;
        }
      }

      // Label
      //
      if (n.name () == "Label" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< LabelType > r (
          LabelTraits::create (i, f, this));

        if (!Label_.present ())
        {
          this->Label_.set (r);
          continue;
        }
      }

      // CompositionPlaylistConstraints
      //
      if (n.name () == "CompositionPlaylistConstraints" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< CompositionPlaylistConstraintsType > r (
          CompositionPlaylistConstraintsTraits::create (i, f, this));

        if (!CompositionPlaylistConstraints_.present ())
        {
          this->CompositionPlaylistConstraints_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!Label_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Label",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!CompositionPlaylistConstraints_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CompositionPlaylistConstraints",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  DeliverableType* DeliverableType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType (*this, f, c);
  }

  DeliverableType& DeliverableType::
  operator= (const DeliverableType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->Label_ = x.Label_;
      this->CompositionPlaylistConstraints_ = x.CompositionPlaylistConstraints_;
    }

    return *this;
  }

  DeliverableType::
  ~DeliverableType ()
  {
  }

  // VirtualTrackType
  //

  VirtualTrackType::
  VirtualTrackType (const KindType& Kind,
                    const EssenceEncodingType& EssenceEncoding)
  : ::xml_schema::Type (),
    Kind_ (Kind, this),
    SoundfieldGroupConfiguration_ (this),
    AudioChannelMapping_ (this),
    EssenceEncoding_ (EssenceEncoding, this),
    EssenceEncodingConstraintList_ (this),
    Colorimetry_ (this),
    Sampling_ (this),
    Quantization_ (this),
    FrameStructure_ (this),
    Stereoscopy_ (this),
    ColorComponents_ (this),
    PixelBitDepthList_ (this),
    ImageFrameWidthList_ (this),
    ImageFrameHeightList_ (this),
    FrameRateList_ (this),
    SampleRateList_ (this),
    TimelineComplexity_ (this),
    ReferenceCardinality_ (this),
    namespace__ (this)
  {
  }

  VirtualTrackType::
  VirtualTrackType (::std::auto_ptr< KindType > Kind,
                    const EssenceEncodingType& EssenceEncoding)
  : ::xml_schema::Type (),
    Kind_ (Kind, this),
    SoundfieldGroupConfiguration_ (this),
    AudioChannelMapping_ (this),
    EssenceEncoding_ (EssenceEncoding, this),
    EssenceEncodingConstraintList_ (this),
    Colorimetry_ (this),
    Sampling_ (this),
    Quantization_ (this),
    FrameStructure_ (this),
    Stereoscopy_ (this),
    ColorComponents_ (this),
    PixelBitDepthList_ (this),
    ImageFrameWidthList_ (this),
    ImageFrameHeightList_ (this),
    FrameRateList_ (this),
    SampleRateList_ (this),
    TimelineComplexity_ (this),
    ReferenceCardinality_ (this),
    namespace__ (this)
  {
  }

  VirtualTrackType::
  VirtualTrackType (const VirtualTrackType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Kind_ (x.Kind_, f, this),
    SoundfieldGroupConfiguration_ (x.SoundfieldGroupConfiguration_, f, this),
    AudioChannelMapping_ (x.AudioChannelMapping_, f, this),
    EssenceEncoding_ (x.EssenceEncoding_, f, this),
    EssenceEncodingConstraintList_ (x.EssenceEncodingConstraintList_, f, this),
    Colorimetry_ (x.Colorimetry_, f, this),
    Sampling_ (x.Sampling_, f, this),
    Quantization_ (x.Quantization_, f, this),
    FrameStructure_ (x.FrameStructure_, f, this),
    Stereoscopy_ (x.Stereoscopy_, f, this),
    ColorComponents_ (x.ColorComponents_, f, this),
    PixelBitDepthList_ (x.PixelBitDepthList_, f, this),
    ImageFrameWidthList_ (x.ImageFrameWidthList_, f, this),
    ImageFrameHeightList_ (x.ImageFrameHeightList_, f, this),
    FrameRateList_ (x.FrameRateList_, f, this),
    SampleRateList_ (x.SampleRateList_, f, this),
    TimelineComplexity_ (x.TimelineComplexity_, f, this),
    ReferenceCardinality_ (x.ReferenceCardinality_, f, this),
    namespace__ (x.namespace__, f, this)
  {
  }

  VirtualTrackType::
  VirtualTrackType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Kind_ (this),
    SoundfieldGroupConfiguration_ (this),
    AudioChannelMapping_ (this),
    EssenceEncoding_ (this),
    EssenceEncodingConstraintList_ (this),
    Colorimetry_ (this),
    Sampling_ (this),
    Quantization_ (this),
    FrameStructure_ (this),
    Stereoscopy_ (this),
    ColorComponents_ (this),
    PixelBitDepthList_ (this),
    ImageFrameWidthList_ (this),
    ImageFrameHeightList_ (this),
    FrameRateList_ (this),
    SampleRateList_ (this),
    TimelineComplexity_ (this),
    ReferenceCardinality_ (this),
    namespace__ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VirtualTrackType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Kind
      //
      if (n.name () == "Kind" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< KindType > r (
          KindTraits::create (i, f, this));

        if (!Kind_.present ())
        {
          this->Kind_.set (r);
          continue;
        }
      }

      // SoundfieldGroupConfiguration
      //
      if (n.name () == "SoundfieldGroupConfiguration" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SoundfieldGroupConfigurationType > r (
          SoundfieldGroupConfigurationTraits::create (i, f, this));

        if (!this->SoundfieldGroupConfiguration_)
        {
          this->SoundfieldGroupConfiguration_.set (r);
          continue;
        }
      }

      // AudioChannelMapping
      //
      if (n.name () == "AudioChannelMapping" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< AudioChannelMappingType > r (
          AudioChannelMappingTraits::create (i, f, this));

        if (!this->AudioChannelMapping_)
        {
          this->AudioChannelMapping_.set (r);
          continue;
        }
      }

      // EssenceEncoding
      //
      if (n.name () == "EssenceEncoding" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< EssenceEncodingType > r (
          EssenceEncodingTraits::create (i, f, this));

        if (!EssenceEncoding_.present ())
        {
          this->EssenceEncoding_.set (r);
          continue;
        }
      }

      // EssenceEncodingConstraintList
      //
      if (n.name () == "EssenceEncodingConstraintList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< EssenceEncodingConstraintListType > r (
          EssenceEncodingConstraintListTraits::create (i, f, this));

        if (!this->EssenceEncodingConstraintList_)
        {
          this->EssenceEncodingConstraintList_.set (r);
          continue;
        }
      }

      // Colorimetry
      //
      if (n.name () == "Colorimetry" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ColorimetryType > r (
          ColorimetryTraits::create (i, f, this));

        if (!this->Colorimetry_)
        {
          this->Colorimetry_.set (r);
          continue;
        }
      }

      // Sampling
      //
      if (n.name () == "Sampling" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SamplingType > r (
          SamplingTraits::create (i, f, this));

        if (!this->Sampling_)
        {
          this->Sampling_.set (r);
          continue;
        }
      }

      // Quantization
      //
      if (n.name () == "Quantization" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< QuantizationType > r (
          QuantizationTraits::create (i, f, this));

        if (!this->Quantization_)
        {
          this->Quantization_.set (r);
          continue;
        }
      }

      // FrameStructure
      //
      if (n.name () == "FrameStructure" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< FrameStructureType > r (
          FrameStructureTraits::create (i, f, this));

        if (!this->FrameStructure_)
        {
          this->FrameStructure_.set (r);
          continue;
        }
      }

      // Stereoscopy
      //
      if (n.name () == "Stereoscopy" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< StereoscopyType > r (
          StereoscopyTraits::create (i, f, this));

        if (!this->Stereoscopy_)
        {
          this->Stereoscopy_.set (r);
          continue;
        }
      }

      // ColorComponents
      //
      if (n.name () == "ColorComponents" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ColorComponentsType > r (
          ColorComponentsTraits::create (i, f, this));

        if (!this->ColorComponents_)
        {
          this->ColorComponents_.set (r);
          continue;
        }
      }

      // PixelBitDepthList
      //
      if (n.name () == "PixelBitDepthList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< PixelBitDepthListType > r (
          PixelBitDepthListTraits::create (i, f, this));

        if (!this->PixelBitDepthList_)
        {
          this->PixelBitDepthList_.set (r);
          continue;
        }
      }

      // ImageFrameWidthList
      //
      if (n.name () == "ImageFrameWidthList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ImageFrameWidthListType > r (
          ImageFrameWidthListTraits::create (i, f, this));

        if (!this->ImageFrameWidthList_)
        {
          this->ImageFrameWidthList_.set (r);
          continue;
        }
      }

      // ImageFrameHeightList
      //
      if (n.name () == "ImageFrameHeightList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ImageFrameHeightListType > r (
          ImageFrameHeightListTraits::create (i, f, this));

        if (!this->ImageFrameHeightList_)
        {
          this->ImageFrameHeightList_.set (r);
          continue;
        }
      }

      // FrameRateList
      //
      if (n.name () == "FrameRateList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< FrameRateListType > r (
          FrameRateListTraits::create (i, f, this));

        if (!this->FrameRateList_)
        {
          this->FrameRateList_.set (r);
          continue;
        }
      }

      // SampleRateList
      //
      if (n.name () == "SampleRateList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SampleRateListType > r (
          SampleRateListTraits::create (i, f, this));

        if (!this->SampleRateList_)
        {
          this->SampleRateList_.set (r);
          continue;
        }
      }

      // TimelineComplexity
      //
      if (n.name () == "TimelineComplexity" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< TimelineComplexityType > r (
          TimelineComplexityTraits::create (i, f, this));

        this->TimelineComplexity_.push_back (r);
        continue;
      }

      // ReferenceCardinality
      //
      if (n.name () == "ReferenceCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ReferenceCardinalityType > r (
          ReferenceCardinalityTraits::create (i, f, this));

        if (!this->ReferenceCardinality_)
        {
          this->ReferenceCardinality_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Kind_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Kind",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!EssenceEncoding_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EssenceEncoding",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "namespace" && n.namespace_ ().empty ())
      {
        this->namespace__.set (NamespaceTraits::create (i, f, this));
        continue;
      }
    }
  }

  VirtualTrackType* VirtualTrackType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType (*this, f, c);
  }

  VirtualTrackType& VirtualTrackType::
  operator= (const VirtualTrackType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Kind_ = x.Kind_;
      this->SoundfieldGroupConfiguration_ = x.SoundfieldGroupConfiguration_;
      this->AudioChannelMapping_ = x.AudioChannelMapping_;
      this->EssenceEncoding_ = x.EssenceEncoding_;
      this->EssenceEncodingConstraintList_ = x.EssenceEncodingConstraintList_;
      this->Colorimetry_ = x.Colorimetry_;
      this->Sampling_ = x.Sampling_;
      this->Quantization_ = x.Quantization_;
      this->FrameStructure_ = x.FrameStructure_;
      this->Stereoscopy_ = x.Stereoscopy_;
      this->ColorComponents_ = x.ColorComponents_;
      this->PixelBitDepthList_ = x.PixelBitDepthList_;
      this->ImageFrameWidthList_ = x.ImageFrameWidthList_;
      this->ImageFrameHeightList_ = x.ImageFrameHeightList_;
      this->FrameRateList_ = x.FrameRateList_;
      this->SampleRateList_ = x.SampleRateList_;
      this->TimelineComplexity_ = x.TimelineComplexity_;
      this->ReferenceCardinality_ = x.ReferenceCardinality_;
      this->namespace__ = x.namespace__;
    }

    return *this;
  }

  VirtualTrackType::
  ~VirtualTrackType ()
  {
  }

  // CardinalityType
  //

  CardinalityType::
  CardinalityType (const MinItemType& MinItem,
                   const MaxItemType& MaxItem)
  : ::xml_schema::Type (),
    MinItem_ (MinItem, this),
    MaxItem_ (MaxItem, this)
  {
  }

  CardinalityType::
  CardinalityType (const CardinalityType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MinItem_ (x.MinItem_, f, this),
    MaxItem_ (x.MaxItem_, f, this)
  {
  }

  CardinalityType::
  CardinalityType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MinItem_ (this),
    MaxItem_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CardinalityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MinItem
      //
      if (n.name () == "MinItem" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< MinItemType > r (
          MinItemTraits::create (i, f, this));

        if (!MinItem_.present ())
        {
          this->MinItem_.set (r);
          continue;
        }
      }

      // MaxItem
      //
      if (n.name () == "MaxItem" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< MaxItemType > r (
          MaxItemTraits::create (i, f, this));

        if (!MaxItem_.present ())
        {
          this->MaxItem_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MinItem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MinItem",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!MaxItem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MaxItem",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  CardinalityType* CardinalityType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CardinalityType (*this, f, c);
  }

  CardinalityType& CardinalityType::
  operator= (const CardinalityType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MinItem_ = x.MinItem_;
      this->MaxItem_ = x.MaxItem_;
    }

    return *this;
  }

  CardinalityType::
  ~CardinalityType ()
  {
  }

  // DeliverySpecificationList
  //

  DeliverySpecificationList::
  DeliverySpecificationList (const IdType& Id,
                             const IssueDateType& IssueDate,
                             const DeliverableListType& DeliverableList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    AnnotationText_ (this),
    IssueDate_ (IssueDate, this),
    Issuer_ (this),
    Creator_ (this),
    DeliverableList_ (DeliverableList, this)
  {
  }

  DeliverySpecificationList::
  DeliverySpecificationList (const IdType& Id,
                             const IssueDateType& IssueDate,
                             ::std::auto_ptr< DeliverableListType > DeliverableList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    AnnotationText_ (this),
    IssueDate_ (IssueDate, this),
    Issuer_ (this),
    Creator_ (this),
    DeliverableList_ (DeliverableList, this)
  {
  }

  DeliverySpecificationList::
  DeliverySpecificationList (const DeliverySpecificationList& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    AnnotationText_ (x.AnnotationText_, f, this),
    IssueDate_ (x.IssueDate_, f, this),
    Issuer_ (x.Issuer_, f, this),
    Creator_ (x.Creator_, f, this),
    DeliverableList_ (x.DeliverableList_, f, this)
  {
  }

  DeliverySpecificationList::
  DeliverySpecificationList (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    AnnotationText_ (this),
    IssueDate_ (this),
    Issuer_ (this),
    Creator_ (this),
    DeliverableList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverySpecificationList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (r);
          continue;
        }
      }

      // AnnotationText
      //
      if (n.name () == "AnnotationText" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< AnnotationTextType > r (
          AnnotationTextTraits::create (i, f, this));

        if (!this->AnnotationText_)
        {
          this->AnnotationText_.set (r);
          continue;
        }
      }

      // IssueDate
      //
      if (n.name () == "IssueDate" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< IssueDateType > r (
          IssueDateTraits::create (i, f, this));

        if (!IssueDate_.present ())
        {
          this->IssueDate_.set (r);
          continue;
        }
      }

      // Issuer
      //
      if (n.name () == "Issuer" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< IssuerType > r (
          IssuerTraits::create (i, f, this));

        if (!this->Issuer_)
        {
          this->Issuer_.set (r);
          continue;
        }
      }

      // Creator
      //
      if (n.name () == "Creator" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< CreatorType > r (
          CreatorTraits::create (i, f, this));

        if (!this->Creator_)
        {
          this->Creator_.set (r);
          continue;
        }
      }

      // DeliverableList
      //
      if (n.name () == "DeliverableList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< DeliverableListType > r (
          DeliverableListTraits::create (i, f, this));

        if (!DeliverableList_.present ())
        {
          this->DeliverableList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!IssueDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IssueDate",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!DeliverableList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeliverableList",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  DeliverySpecificationList* DeliverySpecificationList::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverySpecificationList (*this, f, c);
  }

  DeliverySpecificationList& DeliverySpecificationList::
  operator= (const DeliverySpecificationList& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->AnnotationText_ = x.AnnotationText_;
      this->IssueDate_ = x.IssueDate_;
      this->Issuer_ = x.Issuer_;
      this->Creator_ = x.Creator_;
      this->DeliverableList_ = x.DeliverableList_;
    }

    return *this;
  }

  DeliverySpecificationList::
  ~DeliverySpecificationList ()
  {
  }

  // DeliverableType_LabelType
  //

  DeliverableType_LabelType::
  DeliverableType_LabelType ()
  : ::xml_schema::String ()
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const DeliverableType_LabelType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  DeliverableType_LabelType* DeliverableType_LabelType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_LabelType (*this, f, c);
  }

  DeliverableType_LabelType::
  ~DeliverableType_LabelType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType
  //

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const OwnerIdType& OwnerId,
                                                      const VirtualTrackListType& VirtualTrackList)
  : ::xml_schema::Type (),
    OwnerId_ (OwnerId, this),
    ApplicationIdentificationList_ (this),
    ApplicationIdentification_ (this),
    VirtualTrackList_ (VirtualTrackList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const OwnerIdType& OwnerId,
                                                      ::std::auto_ptr< VirtualTrackListType > VirtualTrackList)
  : ::xml_schema::Type (),
    OwnerId_ (OwnerId, this),
    ApplicationIdentificationList_ (this),
    ApplicationIdentification_ (this),
    VirtualTrackList_ (VirtualTrackList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const DeliverableType_CompositionPlaylistConstraintsType& x,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    OwnerId_ (x.OwnerId_, f, this),
    ApplicationIdentificationList_ (x.ApplicationIdentificationList_, f, this),
    ApplicationIdentification_ (x.ApplicationIdentification_, f, this),
    VirtualTrackList_ (x.VirtualTrackList_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    OwnerId_ (this),
    ApplicationIdentificationList_ (this),
    ApplicationIdentification_ (this),
    VirtualTrackList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OwnerId
      //
      if (n.name () == "OwnerId" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< OwnerIdType > r (
          OwnerIdTraits::create (i, f, this));

        if (!OwnerId_.present ())
        {
          this->OwnerId_.set (r);
          continue;
        }
      }

      // ApplicationIdentificationList
      //
      if (n.name () == "ApplicationIdentificationList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ApplicationIdentificationListType > r (
          ApplicationIdentificationListTraits::create (i, f, this));

        if (!this->ApplicationIdentificationList_)
        {
          this->ApplicationIdentificationList_.set (r);
          continue;
        }
      }

      // ApplicationIdentification
      //
      if (n.name () == "ApplicationIdentification" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ApplicationIdentificationType > r (
          ApplicationIdentificationTraits::create (i, f, this));

        if (!this->ApplicationIdentification_)
        {
          this->ApplicationIdentification_.set (r);
          continue;
        }
      }

      // VirtualTrackList
      //
      if (n.name () == "VirtualTrackList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< VirtualTrackListType > r (
          VirtualTrackListTraits::create (i, f, this));

        if (!VirtualTrackList_.present ())
        {
          this->VirtualTrackList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!OwnerId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OwnerId",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!VirtualTrackList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "VirtualTrackList",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType* DeliverableType_CompositionPlaylistConstraintsType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType& DeliverableType_CompositionPlaylistConstraintsType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->OwnerId_ = x.OwnerId_;
      this->ApplicationIdentificationList_ = x.ApplicationIdentificationList_;
      this->ApplicationIdentification_ = x.ApplicationIdentification_;
      this->VirtualTrackList_ = x.VirtualTrackList_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  ~DeliverableType_CompositionPlaylistConstraintsType ()
  {
  }

  // VirtualTrackType_SoundfieldGroupConfigurationType
  //

  VirtualTrackType_SoundfieldGroupConfigurationType::
  VirtualTrackType_SoundfieldGroupConfigurationType (const MCATagSymbolType& MCATagSymbol)
  : ::xml_schema::Type (),
    MCATagSymbol_ (MCATagSymbol, this)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType::
  VirtualTrackType_SoundfieldGroupConfigurationType (const VirtualTrackType_SoundfieldGroupConfigurationType& x,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MCATagSymbol_ (x.MCATagSymbol_, f, this)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType::
  VirtualTrackType_SoundfieldGroupConfigurationType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MCATagSymbol_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_SoundfieldGroupConfigurationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MCATagSymbol
      //
      if (n.name () == "MCATagSymbol" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< MCATagSymbolType > r (
          MCATagSymbolTraits::create (i, f, this));

        if (!MCATagSymbol_.present ())
        {
          this->MCATagSymbol_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MCATagSymbol_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MCATagSymbol",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  VirtualTrackType_SoundfieldGroupConfigurationType* VirtualTrackType_SoundfieldGroupConfigurationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_SoundfieldGroupConfigurationType (*this, f, c);
  }

  VirtualTrackType_SoundfieldGroupConfigurationType& VirtualTrackType_SoundfieldGroupConfigurationType::
  operator= (const VirtualTrackType_SoundfieldGroupConfigurationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MCATagSymbol_ = x.MCATagSymbol_;
    }

    return *this;
  }

  VirtualTrackType_SoundfieldGroupConfigurationType::
  ~VirtualTrackType_SoundfieldGroupConfigurationType ()
  {
  }

  // VirtualTrackType_AudioChannelMappingType
  //

  VirtualTrackType_AudioChannelMappingType::
  VirtualTrackType_AudioChannelMappingType ()
  : ::xml_schema::Type (),
    AudioChannel_ (this)
  {
  }

  VirtualTrackType_AudioChannelMappingType::
  VirtualTrackType_AudioChannelMappingType (const VirtualTrackType_AudioChannelMappingType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AudioChannel_ (x.AudioChannel_, f, this)
  {
  }

  VirtualTrackType_AudioChannelMappingType::
  VirtualTrackType_AudioChannelMappingType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AudioChannel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_AudioChannelMappingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AudioChannel
      //
      if (n.name () == "AudioChannel" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< AudioChannelType > r (
          AudioChannelTraits::create (i, f, this));

        this->AudioChannel_.push_back (r);
        continue;
      }

      break;
    }
  }

  VirtualTrackType_AudioChannelMappingType* VirtualTrackType_AudioChannelMappingType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_AudioChannelMappingType (*this, f, c);
  }

  VirtualTrackType_AudioChannelMappingType& VirtualTrackType_AudioChannelMappingType::
  operator= (const VirtualTrackType_AudioChannelMappingType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->AudioChannel_ = x.AudioChannel_;
    }

    return *this;
  }

  VirtualTrackType_AudioChannelMappingType::
  ~VirtualTrackType_AudioChannelMappingType ()
  {
  }

  // VirtualTrackType_EssenceEncodingConstraintListType
  //

  VirtualTrackType_EssenceEncodingConstraintListType::
  VirtualTrackType_EssenceEncodingConstraintListType (const ScopeType& scope)
  : ::xml_schema::Type (),
    EssenceEncodingConstraint_ (this),
    scope_ (scope, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType::
  VirtualTrackType_EssenceEncodingConstraintListType (const VirtualTrackType_EssenceEncodingConstraintListType& x,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EssenceEncodingConstraint_ (x.EssenceEncodingConstraint_, f, this),
    scope_ (x.scope_, f, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType::
  VirtualTrackType_EssenceEncodingConstraintListType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EssenceEncodingConstraint_ (this),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_EssenceEncodingConstraintListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EssenceEncodingConstraint
      //
      if (n.name () == "EssenceEncodingConstraint" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< EssenceEncodingConstraintType > r (
          EssenceEncodingConstraintTraits::create (i, f, this));

        this->EssenceEncodingConstraint_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scope",
        "");
    }
  }

  VirtualTrackType_EssenceEncodingConstraintListType* VirtualTrackType_EssenceEncodingConstraintListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_EssenceEncodingConstraintListType (*this, f, c);
  }

  VirtualTrackType_EssenceEncodingConstraintListType& VirtualTrackType_EssenceEncodingConstraintListType::
  operator= (const VirtualTrackType_EssenceEncodingConstraintListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->EssenceEncodingConstraint_ = x.EssenceEncodingConstraint_;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  VirtualTrackType_EssenceEncodingConstraintListType::
  ~VirtualTrackType_EssenceEncodingConstraintListType ()
  {
  }

  // VirtualTrackType_ColorComponentsType
  //

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType ()
  : ::xml_schema::String ()
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const VirtualTrackType_ColorComponentsType& x,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  VirtualTrackType_ColorComponentsType::
  VirtualTrackType_ColorComponentsType (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::Flags f,
                                        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  VirtualTrackType_ColorComponentsType* VirtualTrackType_ColorComponentsType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_ColorComponentsType (*this, f, c);
  }

  VirtualTrackType_ColorComponentsType::
  ~VirtualTrackType_ColorComponentsType ()
  {
  }

  // VirtualTrackType_PixelBitDepthListType
  //

  VirtualTrackType_PixelBitDepthListType::
  VirtualTrackType_PixelBitDepthListType ()
  : ::xml_schema::Type (),
    PixelBitDepth_ (this)
  {
  }

  VirtualTrackType_PixelBitDepthListType::
  VirtualTrackType_PixelBitDepthListType (const VirtualTrackType_PixelBitDepthListType& x,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PixelBitDepth_ (x.PixelBitDepth_, f, this)
  {
  }

  VirtualTrackType_PixelBitDepthListType::
  VirtualTrackType_PixelBitDepthListType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PixelBitDepth_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_PixelBitDepthListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PixelBitDepth
      //
      if (n.name () == "PixelBitDepth" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        this->PixelBitDepth_.push_back (PixelBitDepthTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  VirtualTrackType_PixelBitDepthListType* VirtualTrackType_PixelBitDepthListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_PixelBitDepthListType (*this, f, c);
  }

  VirtualTrackType_PixelBitDepthListType& VirtualTrackType_PixelBitDepthListType::
  operator= (const VirtualTrackType_PixelBitDepthListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->PixelBitDepth_ = x.PixelBitDepth_;
    }

    return *this;
  }

  VirtualTrackType_PixelBitDepthListType::
  ~VirtualTrackType_PixelBitDepthListType ()
  {
  }

  // VirtualTrackType_ImageFrameWidthListType
  //

  VirtualTrackType_ImageFrameWidthListType::
  VirtualTrackType_ImageFrameWidthListType ()
  : ::xml_schema::Type (),
    ImageFrameWidth_ (this)
  {
  }

  VirtualTrackType_ImageFrameWidthListType::
  VirtualTrackType_ImageFrameWidthListType (const VirtualTrackType_ImageFrameWidthListType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ImageFrameWidth_ (x.ImageFrameWidth_, f, this)
  {
  }

  VirtualTrackType_ImageFrameWidthListType::
  VirtualTrackType_ImageFrameWidthListType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ImageFrameWidth_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_ImageFrameWidthListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ImageFrameWidth
      //
      if (n.name () == "ImageFrameWidth" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        this->ImageFrameWidth_.push_back (ImageFrameWidthTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  VirtualTrackType_ImageFrameWidthListType* VirtualTrackType_ImageFrameWidthListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_ImageFrameWidthListType (*this, f, c);
  }

  VirtualTrackType_ImageFrameWidthListType& VirtualTrackType_ImageFrameWidthListType::
  operator= (const VirtualTrackType_ImageFrameWidthListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ImageFrameWidth_ = x.ImageFrameWidth_;
    }

    return *this;
  }

  VirtualTrackType_ImageFrameWidthListType::
  ~VirtualTrackType_ImageFrameWidthListType ()
  {
  }

  // VirtualTrackType_ImageFrameHeightListType
  //

  VirtualTrackType_ImageFrameHeightListType::
  VirtualTrackType_ImageFrameHeightListType ()
  : ::xml_schema::Type (),
    ImageFrameHeight_ (this)
  {
  }

  VirtualTrackType_ImageFrameHeightListType::
  VirtualTrackType_ImageFrameHeightListType (const VirtualTrackType_ImageFrameHeightListType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ImageFrameHeight_ (x.ImageFrameHeight_, f, this)
  {
  }

  VirtualTrackType_ImageFrameHeightListType::
  VirtualTrackType_ImageFrameHeightListType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ImageFrameHeight_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_ImageFrameHeightListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ImageFrameHeight
      //
      if (n.name () == "ImageFrameHeight" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        this->ImageFrameHeight_.push_back (ImageFrameHeightTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  VirtualTrackType_ImageFrameHeightListType* VirtualTrackType_ImageFrameHeightListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_ImageFrameHeightListType (*this, f, c);
  }

  VirtualTrackType_ImageFrameHeightListType& VirtualTrackType_ImageFrameHeightListType::
  operator= (const VirtualTrackType_ImageFrameHeightListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ImageFrameHeight_ = x.ImageFrameHeight_;
    }

    return *this;
  }

  VirtualTrackType_ImageFrameHeightListType::
  ~VirtualTrackType_ImageFrameHeightListType ()
  {
  }

  // VirtualTrackType_FrameRateListType
  //

  VirtualTrackType_FrameRateListType::
  VirtualTrackType_FrameRateListType ()
  : ::xml_schema::Type (),
    FrameRate_ (this)
  {
  }

  VirtualTrackType_FrameRateListType::
  VirtualTrackType_FrameRateListType (const VirtualTrackType_FrameRateListType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    FrameRate_ (x.FrameRate_, f, this)
  {
  }

  VirtualTrackType_FrameRateListType::
  VirtualTrackType_FrameRateListType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    FrameRate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_FrameRateListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FrameRate
      //
      if (n.name () == "FrameRate" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< FrameRateType > r (
          FrameRateTraits::create (i, f, this));

        this->FrameRate_.push_back (r);
        continue;
      }

      break;
    }
  }

  VirtualTrackType_FrameRateListType* VirtualTrackType_FrameRateListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_FrameRateListType (*this, f, c);
  }

  VirtualTrackType_FrameRateListType& VirtualTrackType_FrameRateListType::
  operator= (const VirtualTrackType_FrameRateListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->FrameRate_ = x.FrameRate_;
    }

    return *this;
  }

  VirtualTrackType_FrameRateListType::
  ~VirtualTrackType_FrameRateListType ()
  {
  }

  // VirtualTrackType_SampleRateListType
  //

  VirtualTrackType_SampleRateListType::
  VirtualTrackType_SampleRateListType ()
  : ::xml_schema::Type (),
    SampleRate_ (this)
  {
  }

  VirtualTrackType_SampleRateListType::
  VirtualTrackType_SampleRateListType (const VirtualTrackType_SampleRateListType& x,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SampleRate_ (x.SampleRate_, f, this)
  {
  }

  VirtualTrackType_SampleRateListType::
  VirtualTrackType_SampleRateListType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SampleRate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_SampleRateListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SampleRate
      //
      if (n.name () == "SampleRate" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SampleRateType > r (
          SampleRateTraits::create (i, f, this));

        this->SampleRate_.push_back (r);
        continue;
      }

      break;
    }
  }

  VirtualTrackType_SampleRateListType* VirtualTrackType_SampleRateListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_SampleRateListType (*this, f, c);
  }

  VirtualTrackType_SampleRateListType& VirtualTrackType_SampleRateListType::
  operator= (const VirtualTrackType_SampleRateListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SampleRate_ = x.SampleRate_;
    }

    return *this;
  }

  VirtualTrackType_SampleRateListType::
  ~VirtualTrackType_SampleRateListType ()
  {
  }

  // VirtualTrackType_TimelineComplexityType
  //

  VirtualTrackType_TimelineComplexityType::
  VirtualTrackType_TimelineComplexityType (const SequenceType& Sequence,
                                           const TypeType& type)
  : ::xml_schema::Type (),
    SequenceCardinality_ (this),
    ResourceCardinality_ (this),
    Sequence_ (Sequence, this),
    type_ (type, this)
  {
  }

  VirtualTrackType_TimelineComplexityType::
  VirtualTrackType_TimelineComplexityType (::std::auto_ptr< SequenceType > Sequence,
                                           const TypeType& type)
  : ::xml_schema::Type (),
    SequenceCardinality_ (this),
    ResourceCardinality_ (this),
    Sequence_ (Sequence, this),
    type_ (type, this)
  {
  }

  VirtualTrackType_TimelineComplexityType::
  VirtualTrackType_TimelineComplexityType (const VirtualTrackType_TimelineComplexityType& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SequenceCardinality_ (x.SequenceCardinality_, f, this),
    ResourceCardinality_ (x.ResourceCardinality_, f, this),
    Sequence_ (x.Sequence_, f, this),
    type_ (x.type_, f, this)
  {
  }

  VirtualTrackType_TimelineComplexityType::
  VirtualTrackType_TimelineComplexityType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SequenceCardinality_ (this),
    ResourceCardinality_ (this),
    Sequence_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_TimelineComplexityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SequenceCardinality
      //
      if (n.name () == "SequenceCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SequenceCardinalityType > r (
          SequenceCardinalityTraits::create (i, f, this));

        if (!this->SequenceCardinality_)
        {
          this->SequenceCardinality_.set (r);
          continue;
        }
      }

      // ResourceCardinality
      //
      if (n.name () == "ResourceCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ResourceCardinalityType > r (
          ResourceCardinalityTraits::create (i, f, this));

        if (!this->ResourceCardinality_)
        {
          this->ResourceCardinality_.set (r);
          continue;
        }
      }

      // Sequence
      //
      if (n.name () == "Sequence" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SequenceType > r (
          SequenceTraits::create (i, f, this));

        if (!Sequence_.present ())
        {
          this->Sequence_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Sequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Sequence",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  VirtualTrackType_TimelineComplexityType* VirtualTrackType_TimelineComplexityType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_TimelineComplexityType (*this, f, c);
  }

  VirtualTrackType_TimelineComplexityType& VirtualTrackType_TimelineComplexityType::
  operator= (const VirtualTrackType_TimelineComplexityType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SequenceCardinality_ = x.SequenceCardinality_;
      this->ResourceCardinality_ = x.ResourceCardinality_;
      this->Sequence_ = x.Sequence_;
      this->type_ = x.type_;
    }

    return *this;
  }

  VirtualTrackType_TimelineComplexityType::
  ~VirtualTrackType_TimelineComplexityType ()
  {
  }

  // VirtualTrackType_ReferenceCardinalityType
  //

  VirtualTrackType_ReferenceCardinalityType::
  VirtualTrackType_ReferenceCardinalityType (const SequenceType& Sequence)
  : ::xml_schema::Type (),
    Sequence_ (Sequence, this)
  {
  }

  VirtualTrackType_ReferenceCardinalityType::
  VirtualTrackType_ReferenceCardinalityType (::std::auto_ptr< SequenceType > Sequence)
  : ::xml_schema::Type (),
    Sequence_ (Sequence, this)
  {
  }

  VirtualTrackType_ReferenceCardinalityType::
  VirtualTrackType_ReferenceCardinalityType (const VirtualTrackType_ReferenceCardinalityType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Sequence_ (x.Sequence_, f, this)
  {
  }

  VirtualTrackType_ReferenceCardinalityType::
  VirtualTrackType_ReferenceCardinalityType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Sequence_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_ReferenceCardinalityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sequence
      //
      if (n.name () == "Sequence" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< SequenceType > r (
          SequenceTraits::create (i, f, this));

        if (!Sequence_.present ())
        {
          this->Sequence_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Sequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Sequence",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  VirtualTrackType_ReferenceCardinalityType* VirtualTrackType_ReferenceCardinalityType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_ReferenceCardinalityType (*this, f, c);
  }

  VirtualTrackType_ReferenceCardinalityType& VirtualTrackType_ReferenceCardinalityType::
  operator= (const VirtualTrackType_ReferenceCardinalityType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Sequence_ = x.Sequence_;
    }

    return *this;
  }

  VirtualTrackType_ReferenceCardinalityType::
  ~VirtualTrackType_ReferenceCardinalityType ()
  {
  }

  // VirtualTrackType_namespaceType
  //

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType ()
  : ::xml_schema::String ()
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const VirtualTrackType_namespaceType& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  VirtualTrackType_namespaceType::
  VirtualTrackType_namespaceType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  VirtualTrackType_namespaceType* VirtualTrackType_namespaceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_namespaceType (*this, f, c);
  }

  VirtualTrackType_namespaceType::
  ~VirtualTrackType_namespaceType ()
  {
  }

  // CardinalityType_MinItemType
  //

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const CardinalityType_MinItemType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  CardinalityType_MinItemType* CardinalityType_MinItemType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CardinalityType_MinItemType (*this, f, c);
  }

  CardinalityType_MinItemType::
  ~CardinalityType_MinItemType ()
  {
  }

  // CardinalityType_MaxItemType
  //

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const CardinalityType_MaxItemType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  CardinalityType_MaxItemType* CardinalityType_MaxItemType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CardinalityType_MaxItemType (*this, f, c);
  }

  CardinalityType_MaxItemType::
  ~CardinalityType_MaxItemType ()
  {
  }

  // DeliverySpecificationList_DeliverableListType
  //

  DeliverySpecificationList_DeliverableListType::
  DeliverySpecificationList_DeliverableListType ()
  : ::xml_schema::Type (),
    Deliverable_ (this)
  {
  }

  DeliverySpecificationList_DeliverableListType::
  DeliverySpecificationList_DeliverableListType (const DeliverySpecificationList_DeliverableListType& x,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Deliverable_ (x.Deliverable_, f, this)
  {
  }

  DeliverySpecificationList_DeliverableListType::
  DeliverySpecificationList_DeliverableListType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Deliverable_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverySpecificationList_DeliverableListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Deliverable
      //
      if (n.name () == "Deliverable" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< DeliverableType > r (
          DeliverableTraits::create (i, f, this));

        this->Deliverable_.push_back (r);
        continue;
      }

      break;
    }
  }

  DeliverySpecificationList_DeliverableListType* DeliverySpecificationList_DeliverableListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverySpecificationList_DeliverableListType (*this, f, c);
  }

  DeliverySpecificationList_DeliverableListType& DeliverySpecificationList_DeliverableListType::
  operator= (const DeliverySpecificationList_DeliverableListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Deliverable_ = x.Deliverable_;
    }

    return *this;
  }

  DeliverySpecificationList_DeliverableListType::
  ~DeliverySpecificationList_DeliverableListType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType
  //

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const MatchTypeType& MatchType,
                                                                                        const ValueListType& ValueList)
  : ::xml_schema::Type (),
    MatchType_ (MatchType, this),
    ValueList_ (ValueList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const MatchTypeType& MatchType,
                                                                                        ::std::auto_ptr< ValueListType > ValueList)
  : ::xml_schema::Type (),
    MatchType_ (MatchType, this),
    ValueList_ (ValueList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& x,
                                                                                        ::xml_schema::Flags f,
                                                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MatchType_ (x.MatchType_, f, this),
    ValueList_ (x.ValueList_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const ::xercesc::DOMElement& e,
                                                                                        ::xml_schema::Flags f,
                                                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MatchType_ (this),
    ValueList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MatchType
      //
      if (n.name () == "MatchType" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< MatchTypeType > r (
          MatchTypeTraits::create (i, f, this));

        if (!MatchType_.present ())
        {
          this->MatchType_.set (r);
          continue;
        }
      }

      // ValueList
      //
      if (n.name () == "ValueList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ValueListType > r (
          ValueListTraits::create (i, f, this));

        if (!ValueList_.present ())
        {
          this->ValueList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MatchType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MatchType",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!ValueList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ValueList",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType* DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MatchType_ = x.MatchType_;
      this->ValueList_ = x.ValueList_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  ~DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType
  //

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType ()
  : ::xml_schema::Type (),
    VirtualTrack_ (this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType (const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& x,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    VirtualTrack_ (x.VirtualTrack_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType (const ::xercesc::DOMElement& e,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    VirtualTrack_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // VirtualTrack
      //
      if (n.name () == "VirtualTrack" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< VirtualTrackType > r (
          VirtualTrackTraits::create (i, f, this));

        this->VirtualTrack_.push_back (r);
        continue;
      }

      break;
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType* DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->VirtualTrack_ = x.VirtualTrack_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  ~DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType ()
  {
  }

  // VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType
  //

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType ()
  : ::xml_schema::String ()
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& x,
                                                                      ::xml_schema::Flags f,
                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::xercesc::DOMElement& e,
                                                                      ::xml_schema::Flags f,
                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::xercesc::DOMAttr& a,
                                                                      ::xml_schema::Flags f,
                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::std::string& s,
                                                                      const ::xercesc::DOMElement* e,
                                                                      ::xml_schema::Flags f,
                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType* VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (*this, f, c);
  }

  VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  ~VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType ()
  {
  }

  // VirtualTrackType_AudioChannelMappingType_AudioChannelType
  //

  VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType (const MCATagSymbolType& MCATagSymbol)
  : ::xml_schema::Type (),
    MCATagSymbol_ (MCATagSymbol, this)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType (const VirtualTrackType_AudioChannelMappingType_AudioChannelType& x,
                                                             ::xml_schema::Flags f,
                                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MCATagSymbol_ (x.MCATagSymbol_, f, this)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType (const ::xercesc::DOMElement& e,
                                                             ::xml_schema::Flags f,
                                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MCATagSymbol_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MCATagSymbol
      //
      if (n.name () == "MCATagSymbol" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< MCATagSymbolType > r (
          MCATagSymbolTraits::create (i, f, this));

        if (!MCATagSymbol_.present ())
        {
          this->MCATagSymbol_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MCATagSymbol_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MCATagSymbol",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType* VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_AudioChannelMappingType_AudioChannelType (*this, f, c);
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType& VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  operator= (const VirtualTrackType_AudioChannelMappingType_AudioChannelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MCATagSymbol_ = x.MCATagSymbol_;
    }

    return *this;
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType::
  ~VirtualTrackType_AudioChannelMappingType_AudioChannelType ()
  {
  }

  // VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType
  //

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const NameType& Name,
                                                                                    const PropertyListType& PropertyList)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    PropertyList_ (PropertyList, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const NameType& Name,
                                                                                    ::std::auto_ptr< PropertyListType > PropertyList)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    PropertyList_ (PropertyList, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& x,
                                                                                    ::xml_schema::Flags f,
                                                                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Name_ (x.Name_, f, this),
    PropertyList_ (x.PropertyList_, f, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const ::xercesc::DOMElement& e,
                                                                                    ::xml_schema::Flags f,
                                                                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Name_ (this),
    PropertyList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (r);
          continue;
        }
      }

      // PropertyList
      //
      if (n.name () == "PropertyList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< PropertyListType > r (
          PropertyListTraits::create (i, f, this));

        if (!PropertyList_.present ())
        {
          this->PropertyList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Name",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!PropertyList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PropertyList",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType* VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (*this, f, c);
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  operator= (const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Name_ = x.Name_;
      this->PropertyList_ = x.PropertyList_;
    }

    return *this;
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  ~VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType ()
  {
  }

  // VirtualTrackType_TimelineComplexityType_SequenceType
  //

  VirtualTrackType_TimelineComplexityType_SequenceType::
  VirtualTrackType_TimelineComplexityType_SequenceType (const ResourceType& Resource)
  : ::xml_schema::Type (),
    Cardinality_ (this),
    Resource_ (Resource, this)
  {
  }

  VirtualTrackType_TimelineComplexityType_SequenceType::
  VirtualTrackType_TimelineComplexityType_SequenceType (::std::auto_ptr< ResourceType > Resource)
  : ::xml_schema::Type (),
    Cardinality_ (this),
    Resource_ (Resource, this)
  {
  }

  VirtualTrackType_TimelineComplexityType_SequenceType::
  VirtualTrackType_TimelineComplexityType_SequenceType (const VirtualTrackType_TimelineComplexityType_SequenceType& x,
                                                        ::xml_schema::Flags f,
                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Cardinality_ (x.Cardinality_, f, this),
    Resource_ (x.Resource_, f, this)
  {
  }

  VirtualTrackType_TimelineComplexityType_SequenceType::
  VirtualTrackType_TimelineComplexityType_SequenceType (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::Flags f,
                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Cardinality_ (this),
    Resource_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Cardinality
      //
      if (n.name () == "Cardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< CardinalityType > r (
          CardinalityTraits::create (i, f, this));

        if (!this->Cardinality_)
        {
          this->Cardinality_.set (r);
          continue;
        }
      }

      // Resource
      //
      if (n.name () == "Resource" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ResourceType > r (
          ResourceTraits::create (i, f, this));

        if (!Resource_.present ())
        {
          this->Resource_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Resource_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Resource",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  VirtualTrackType_TimelineComplexityType_SequenceType* VirtualTrackType_TimelineComplexityType_SequenceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_TimelineComplexityType_SequenceType (*this, f, c);
  }

  VirtualTrackType_TimelineComplexityType_SequenceType& VirtualTrackType_TimelineComplexityType_SequenceType::
  operator= (const VirtualTrackType_TimelineComplexityType_SequenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Cardinality_ = x.Cardinality_;
      this->Resource_ = x.Resource_;
    }

    return *this;
  }

  VirtualTrackType_TimelineComplexityType_SequenceType::
  ~VirtualTrackType_TimelineComplexityType_SequenceType ()
  {
  }

  // VirtualTrackType_TimelineComplexityType_typeType
  //

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType ()
  : ::xml_schema::String ()
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const VirtualTrackType_TimelineComplexityType_typeType& x,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  VirtualTrackType_TimelineComplexityType_typeType (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  VirtualTrackType_TimelineComplexityType_typeType* VirtualTrackType_TimelineComplexityType_typeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_TimelineComplexityType_typeType (*this, f, c);
  }

  VirtualTrackType_TimelineComplexityType_typeType::
  ~VirtualTrackType_TimelineComplexityType_typeType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType
  //

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType ()
  : ::xml_schema::String ()
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& x,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::xercesc::DOMElement& e,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::xercesc::DOMAttr& a,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::std::string& s,
                                                                                                      const ::xercesc::DOMElement* e,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType* DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  ~DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType
  //

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType ()
  : ::xml_schema::Type (),
    ApplicationIdentification_ (this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& x,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ApplicationIdentification_ (x.ApplicationIdentification_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType (const ::xercesc::DOMElement& e,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ApplicationIdentification_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ApplicationIdentification
      //
      if (n.name () == "ApplicationIdentification" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ApplicationIdentificationType > r (
          ApplicationIdentificationTraits::create (i, f, this));

        this->ApplicationIdentification_.push_back (r);
        continue;
      }

      break;
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType* DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ApplicationIdentification_ = x.ApplicationIdentification_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  ~DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType ()
  {
  }

  // VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType
  //

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType ()
  : ::xml_schema::String ()
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& x,
                                                                              ::xml_schema::Flags f,
                                                                              ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::xercesc::DOMElement& e,
                                                                              ::xml_schema::Flags f,
                                                                              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::xercesc::DOMAttr& a,
                                                                              ::xml_schema::Flags f,
                                                                              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::std::string& s,
                                                                              const ::xercesc::DOMElement* e,
                                                                              ::xml_schema::Flags f,
                                                                              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType* VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (*this, f, c);
  }

  VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  ~VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType ()
  {
  }

  // VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType
  //

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType ()
  : ::xml_schema::Type (),
    Property_ (this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType (const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& x,
                                                                                                     ::xml_schema::Flags f,
                                                                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Property_ (x.Property_, f, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType (const ::xercesc::DOMElement& e,
                                                                                                     ::xml_schema::Flags f,
                                                                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Property_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Property
      //
      if (n.name () == "Property" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< PropertyType > r (
          PropertyTraits::create (i, f, this));

        this->Property_.push_back (r);
        continue;
      }

      break;
    }
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType* VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType (*this, f, c);
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  operator= (const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Property_ = x.Property_;
    }

    return *this;
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  ~VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType ()
  {
  }

  // VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType
  //

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType ()
  : ::xml_schema::Type (),
    Cardinality_ (this)
  {
  }

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType (const VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& x,
                                                                     ::xml_schema::Flags f,
                                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Cardinality_ (x.Cardinality_, f, this)
  {
  }

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType (const ::xercesc::DOMElement& e,
                                                                     ::xml_schema::Flags f,
                                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Cardinality_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Cardinality
      //
      if (n.name () == "Cardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< CardinalityType > r (
          CardinalityTraits::create (i, f, this));

        if (!this->Cardinality_)
        {
          this->Cardinality_.set (r);
          continue;
        }
      }

      break;
    }
  }

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType* VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType (*this, f, c);
  }

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  operator= (const VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Cardinality_ = x.Cardinality_;
    }

    return *this;
  }

  VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  ~VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType ()
  {
  }

  // VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType
  //

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (const NameType& Name,
                                                                                                                  const ValueType& value)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    value_ (value, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& x,
                                                                                                                  ::xml_schema::Flags f,
                                                                                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Name_ (x.Name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (const ::xercesc::DOMElement& e,
                                                                                                                  ::xml_schema::Flags f,
                                                                                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Name_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
      {
        ::std::auto_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Name",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType* VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (*this, f, c);
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  operator= (const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Name_ = x.Name_;
      this->value_ = x.value_;
    }

    return *this;
  }

  VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  ~VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType ()
  {
  }
}

#include <ostream>

namespace dsl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    o << ::std::endl << "Label: " << i.getLabel ();
    o << ::std::endl << "CompositionPlaylistConstraints: " << i.getCompositionPlaylistConstraints ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType& i)
  {
    o << ::std::endl << "Kind: " << i.getKind ();
    if (i.getSoundfieldGroupConfiguration ())
    {
      o << ::std::endl << "SoundfieldGroupConfiguration: " << *i.getSoundfieldGroupConfiguration ();
    }

    if (i.getAudioChannelMapping ())
    {
      o << ::std::endl << "AudioChannelMapping: " << *i.getAudioChannelMapping ();
    }

    o << ::std::endl << "EssenceEncoding: " << i.getEssenceEncoding ();
    if (i.getEssenceEncodingConstraintList ())
    {
      o << ::std::endl << "EssenceEncodingConstraintList: " << *i.getEssenceEncodingConstraintList ();
    }

    if (i.getColorimetry ())
    {
      o << ::std::endl << "Colorimetry: " << *i.getColorimetry ();
    }

    if (i.getSampling ())
    {
      o << ::std::endl << "Sampling: " << *i.getSampling ();
    }

    if (i.getQuantization ())
    {
      o << ::std::endl << "Quantization: " << *i.getQuantization ();
    }

    if (i.getFrameStructure ())
    {
      o << ::std::endl << "FrameStructure: " << *i.getFrameStructure ();
    }

    if (i.getStereoscopy ())
    {
      o << ::std::endl << "Stereoscopy: " << *i.getStereoscopy ();
    }

    if (i.getColorComponents ())
    {
      o << ::std::endl << "ColorComponents: " << *i.getColorComponents ();
    }

    if (i.getPixelBitDepthList ())
    {
      o << ::std::endl << "PixelBitDepthList: " << *i.getPixelBitDepthList ();
    }

    if (i.getImageFrameWidthList ())
    {
      o << ::std::endl << "ImageFrameWidthList: " << *i.getImageFrameWidthList ();
    }

    if (i.getImageFrameHeightList ())
    {
      o << ::std::endl << "ImageFrameHeightList: " << *i.getImageFrameHeightList ();
    }

    if (i.getFrameRateList ())
    {
      o << ::std::endl << "FrameRateList: " << *i.getFrameRateList ();
    }

    if (i.getSampleRateList ())
    {
      o << ::std::endl << "SampleRateList: " << *i.getSampleRateList ();
    }

    for (VirtualTrackType::TimelineComplexityConstIterator
         b (i.getTimelineComplexity ().begin ()), e (i.getTimelineComplexity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "TimelineComplexity: " << *b;
    }

    if (i.getReferenceCardinality ())
    {
      o << ::std::endl << "ReferenceCardinality: " << *i.getReferenceCardinality ();
    }

    if (i.getNamespace ())
    {
      o << ::std::endl << "namespace: " << *i.getNamespace ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CardinalityType& i)
  {
    o << ::std::endl << "MinItem: " << i.getMinItem ();
    o << ::std::endl << "MaxItem: " << i.getMaxItem ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverySpecificationList& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    if (i.getAnnotationText ())
    {
      o << ::std::endl << "AnnotationText: " << *i.getAnnotationText ();
    }

    o << ::std::endl << "IssueDate: " << i.getIssueDate ();
    if (i.getIssuer ())
    {
      o << ::std::endl << "Issuer: " << *i.getIssuer ();
    }

    if (i.getCreator ())
    {
      o << ::std::endl << "Creator: " << *i.getCreator ();
    }

    o << ::std::endl << "DeliverableList: " << i.getDeliverableList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_LabelType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType& i)
  {
    o << ::std::endl << "OwnerId: " << i.getOwnerId ();
    if (i.getApplicationIdentificationList ())
    {
      o << ::std::endl << "ApplicationIdentificationList: " << *i.getApplicationIdentificationList ();
    }

    if (i.getApplicationIdentification ())
    {
      o << ::std::endl << "ApplicationIdentification: " << *i.getApplicationIdentification ();
    }

    o << ::std::endl << "VirtualTrackList: " << i.getVirtualTrackList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_SoundfieldGroupConfigurationType& i)
  {
    o << ::std::endl << "MCATagSymbol: " << i.getMCATagSymbol ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_AudioChannelMappingType& i)
  {
    for (VirtualTrackType_AudioChannelMappingType::AudioChannelConstIterator
         b (i.getAudioChannel ().begin ()), e (i.getAudioChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "AudioChannel: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_EssenceEncodingConstraintListType& i)
  {
    for (VirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintConstIterator
         b (i.getEssenceEncodingConstraint ().begin ()), e (i.getEssenceEncodingConstraint ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "EssenceEncodingConstraint: " << *b;
    }

    o << ::std::endl << "scope: " << i.getScope ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_ColorComponentsType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_PixelBitDepthListType& i)
  {
    for (VirtualTrackType_PixelBitDepthListType::PixelBitDepthConstIterator
         b (i.getPixelBitDepth ().begin ()), e (i.getPixelBitDepth ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "PixelBitDepth: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_ImageFrameWidthListType& i)
  {
    for (VirtualTrackType_ImageFrameWidthListType::ImageFrameWidthConstIterator
         b (i.getImageFrameWidth ().begin ()), e (i.getImageFrameWidth ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ImageFrameWidth: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_ImageFrameHeightListType& i)
  {
    for (VirtualTrackType_ImageFrameHeightListType::ImageFrameHeightConstIterator
         b (i.getImageFrameHeight ().begin ()), e (i.getImageFrameHeight ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ImageFrameHeight: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_FrameRateListType& i)
  {
    for (VirtualTrackType_FrameRateListType::FrameRateConstIterator
         b (i.getFrameRate ().begin ()), e (i.getFrameRate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "FrameRate: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_SampleRateListType& i)
  {
    for (VirtualTrackType_SampleRateListType::SampleRateConstIterator
         b (i.getSampleRate ().begin ()), e (i.getSampleRate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "SampleRate: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_TimelineComplexityType& i)
  {
    if (i.getSequenceCardinality ())
    {
      o << ::std::endl << "SequenceCardinality: " << *i.getSequenceCardinality ();
    }

    if (i.getResourceCardinality ())
    {
      o << ::std::endl << "ResourceCardinality: " << *i.getResourceCardinality ();
    }

    o << ::std::endl << "Sequence: " << i.getSequence ();
    o << ::std::endl << "type: " << i.getType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_ReferenceCardinalityType& i)
  {
    o << ::std::endl << "Sequence: " << i.getSequence ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_namespaceType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CardinalityType_MinItemType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CardinalityType_MaxItemType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverySpecificationList_DeliverableListType& i)
  {
    for (DeliverySpecificationList_DeliverableListType::DeliverableConstIterator
         b (i.getDeliverable ().begin ()), e (i.getDeliverable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Deliverable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& i)
  {
    o << ::std::endl << "MatchType: " << i.getMatchType ();
    o << ::std::endl << "ValueList: " << i.getValueList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& i)
  {
    for (DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::VirtualTrackConstIterator
         b (i.getVirtualTrack ().begin ()), e (i.getVirtualTrack ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "VirtualTrack: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_AudioChannelMappingType_AudioChannelType& i)
  {
    o << ::std::endl << "MCATagSymbol: " << i.getMCATagSymbol ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& i)
  {
    o << ::std::endl << "Name: " << i.getName ();
    o << ::std::endl << "PropertyList: " << i.getPropertyList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_TimelineComplexityType_SequenceType& i)
  {
    if (i.getCardinality ())
    {
      o << ::std::endl << "Cardinality: " << *i.getCardinality ();
    }

    o << ::std::endl << "Resource: " << i.getResource ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_TimelineComplexityType_typeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& i)
  {
    for (DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationConstIterator
         b (i.getApplicationIdentification ().begin ()), e (i.getApplicationIdentification ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ApplicationIdentification: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& i)
  {
    for (VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertyConstIterator
         b (i.getProperty ().begin ()), e (i.getProperty ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Property: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& i)
  {
    if (i.getCardinality ())
    {
      o << ::std::endl << "Cardinality: " << *i.getCardinality ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& i)
  {
    o << ::std::endl << "Name: " << i.getName ();
    o << ::std::endl << "value: " << i.getValue ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dsl
{
  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::std::string& u,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::std::string& u,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dsl::parseDeliverySpecificationList (isrc, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dsl::parseDeliverySpecificationList (isrc, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xercesc::InputSource& i,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xercesc::InputSource& i,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::xercesc::DOMDocument& doc,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
        ::dsl::parseDeliverySpecificationList (
          d, f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DeliverySpecificationList" &&
        n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
    {
      ::std::auto_ptr< ::dsl::DeliverySpecificationList > r (
        ::xsd::cxx::tree::traits< ::dsl::DeliverySpecificationList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DeliverySpecificationList",
      "http://www.imfug.com/ns/delivery-schema/2018");
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DeliverySpecificationList" &&
        n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
    {
      ::std::auto_ptr< ::dsl::DeliverySpecificationList > r (
        ::xsd::cxx::tree::traits< ::dsl::DeliverySpecificationList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DeliverySpecificationList",
      "http://www.imfug.com/ns/delivery-schema/2018");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace dsl
{
  void
  serializeDeliverySpecificationList (::std::ostream& o,
                                      const ::dsl::DeliverySpecificationList& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeDeliverySpecificationList (::std::ostream& o,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xml_schema::ErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::std::ostream& o,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xercesc::DOMErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::XMLFormatTarget& t,
                                      const ::dsl::DeliverySpecificationList& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::XMLFormatTarget& t,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xml_schema::ErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::XMLFormatTarget& t,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xercesc::DOMErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::DOMDocument& d,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DeliverySpecificationList" &&
        n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2018")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DeliverySpecificationList",
        "http://www.imfug.com/ns/delivery-schema/2018");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeDeliverySpecificationList (const ::dsl::DeliverySpecificationList& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "DeliverySpecificationList",
        "http://www.imfug.com/ns/delivery-schema/2018",
        m, f));

    ::dsl::serializeDeliverySpecificationList (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getId ();
    }

    // Label
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Label",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getLabel ();
    }

    // CompositionPlaylistConstraints
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CompositionPlaylistConstraints",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getCompositionPlaylistConstraints ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Kind
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Kind",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getKind ();
    }

    // SoundfieldGroupConfiguration
    //
    if (i.getSoundfieldGroupConfiguration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SoundfieldGroupConfiguration",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getSoundfieldGroupConfiguration ();
    }

    // AudioChannelMapping
    //
    if (i.getAudioChannelMapping ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AudioChannelMapping",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getAudioChannelMapping ();
    }

    // EssenceEncoding
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncoding",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getEssenceEncoding ();
    }

    // EssenceEncodingConstraintList
    //
    if (i.getEssenceEncodingConstraintList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncodingConstraintList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getEssenceEncodingConstraintList ();
    }

    // Colorimetry
    //
    if (i.getColorimetry ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Colorimetry",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getColorimetry ();
    }

    // Sampling
    //
    if (i.getSampling ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sampling",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getSampling ();
    }

    // Quantization
    //
    if (i.getQuantization ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Quantization",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getQuantization ();
    }

    // FrameStructure
    //
    if (i.getFrameStructure ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FrameStructure",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getFrameStructure ();
    }

    // Stereoscopy
    //
    if (i.getStereoscopy ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Stereoscopy",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getStereoscopy ();
    }

    // ColorComponents
    //
    if (i.getColorComponents ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ColorComponents",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getColorComponents ();
    }

    // PixelBitDepthList
    //
    if (i.getPixelBitDepthList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PixelBitDepthList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getPixelBitDepthList ();
    }

    // ImageFrameWidthList
    //
    if (i.getImageFrameWidthList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameWidthList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getImageFrameWidthList ();
    }

    // ImageFrameHeightList
    //
    if (i.getImageFrameHeightList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameHeightList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getImageFrameHeightList ();
    }

    // FrameRateList
    //
    if (i.getFrameRateList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FrameRateList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getFrameRateList ();
    }

    // SampleRateList
    //
    if (i.getSampleRateList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SampleRateList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getSampleRateList ();
    }

    // TimelineComplexity
    //
    for (VirtualTrackType::TimelineComplexityConstIterator
         b (i.getTimelineComplexity ().begin ()), n (i.getTimelineComplexity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimelineComplexity",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }

    // ReferenceCardinality
    //
    if (i.getReferenceCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReferenceCardinality",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getReferenceCardinality ();
    }

    // namespace
    //
    if (i.getNamespace ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "namespace",
          e));

      a << *i.getNamespace ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CardinalityType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MinItem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MinItem",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getMinItem ();
    }

    // MaxItem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MaxItem",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getMaxItem ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverySpecificationList& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getId ();
    }

    // AnnotationText
    //
    if (i.getAnnotationText ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnnotationText",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getAnnotationText ();
    }

    // IssueDate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IssueDate",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getIssueDate ();
    }

    // Issuer
    //
    if (i.getIssuer ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Issuer",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getIssuer ();
    }

    // Creator
    //
    if (i.getCreator ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Creator",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getCreator ();
    }

    // DeliverableList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeliverableList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getDeliverableList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_LabelType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DeliverableType_LabelType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DeliverableType_LabelType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // OwnerId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OwnerId",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getOwnerId ();
    }

    // ApplicationIdentificationList
    //
    if (i.getApplicationIdentificationList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplicationIdentificationList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getApplicationIdentificationList ();
    }

    // ApplicationIdentification
    //
    if (i.getApplicationIdentification ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplicationIdentification",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getApplicationIdentification ();
    }

    // VirtualTrackList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "VirtualTrackList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getVirtualTrackList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_SoundfieldGroupConfigurationType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MCATagSymbol
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MCATagSymbol",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getMCATagSymbol ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_AudioChannelMappingType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AudioChannel
    //
    for (VirtualTrackType_AudioChannelMappingType::AudioChannelConstIterator
         b (i.getAudioChannel ().begin ()), n (i.getAudioChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AudioChannel",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_EssenceEncodingConstraintListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EssenceEncodingConstraint
    //
    for (VirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintConstIterator
         b (i.getEssenceEncodingConstraint ().begin ()), n (i.getEssenceEncodingConstraint ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncodingConstraint",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }

    // scope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << i.getScope ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_ColorComponentsType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VirtualTrackType_ColorComponentsType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VirtualTrackType_ColorComponentsType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_PixelBitDepthListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PixelBitDepth
    //
    for (VirtualTrackType_PixelBitDepthListType::PixelBitDepthConstIterator
         b (i.getPixelBitDepth ().begin ()), n (i.getPixelBitDepth ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PixelBitDepth",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_ImageFrameWidthListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ImageFrameWidth
    //
    for (VirtualTrackType_ImageFrameWidthListType::ImageFrameWidthConstIterator
         b (i.getImageFrameWidth ().begin ()), n (i.getImageFrameWidth ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameWidth",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_ImageFrameHeightListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ImageFrameHeight
    //
    for (VirtualTrackType_ImageFrameHeightListType::ImageFrameHeightConstIterator
         b (i.getImageFrameHeight ().begin ()), n (i.getImageFrameHeight ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameHeight",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_FrameRateListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // FrameRate
    //
    for (VirtualTrackType_FrameRateListType::FrameRateConstIterator
         b (i.getFrameRate ().begin ()), n (i.getFrameRate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FrameRate",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_SampleRateListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SampleRate
    //
    for (VirtualTrackType_SampleRateListType::SampleRateConstIterator
         b (i.getSampleRate ().begin ()), n (i.getSampleRate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SampleRate",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_TimelineComplexityType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SequenceCardinality
    //
    if (i.getSequenceCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SequenceCardinality",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getSequenceCardinality ();
    }

    // ResourceCardinality
    //
    if (i.getResourceCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ResourceCardinality",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getResourceCardinality ();
    }

    // Sequence
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sequence",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getSequence ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_ReferenceCardinalityType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Sequence
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sequence",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getSequence ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_namespaceType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VirtualTrackType_namespaceType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VirtualTrackType_namespaceType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CardinalityType_MinItemType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CardinalityType_MinItemType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CardinalityType_MinItemType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CardinalityType_MaxItemType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CardinalityType_MaxItemType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CardinalityType_MaxItemType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverySpecificationList_DeliverableListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Deliverable
    //
    for (DeliverySpecificationList_DeliverableListType::DeliverableConstIterator
         b (i.getDeliverable ().begin ()), n (i.getDeliverable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Deliverable",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MatchType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MatchType",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getMatchType ();
    }

    // ValueList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ValueList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getValueList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // VirtualTrack
    //
    for (DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::VirtualTrackConstIterator
         b (i.getVirtualTrack ().begin ()), n (i.getVirtualTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "VirtualTrack",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_AudioChannelMappingType_AudioChannelType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MCATagSymbol
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MCATagSymbol",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getMCATagSymbol ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getName ();
    }

    // PropertyList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PropertyList",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getPropertyList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_TimelineComplexityType_SequenceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Cardinality
    //
    if (i.getCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Cardinality",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getCardinality ();
    }

    // Resource
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Resource",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getResource ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_TimelineComplexityType_typeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VirtualTrackType_TimelineComplexityType_typeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VirtualTrackType_TimelineComplexityType_typeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ApplicationIdentification
    //
    for (DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationConstIterator
         b (i.getApplicationIdentification ().begin ()), n (i.getApplicationIdentification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplicationIdentification",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Property
    //
    for (VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertyConstIterator
         b (i.getProperty ().begin ()), n (i.getProperty ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Property",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Cardinality
    //
    if (i.getCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Cardinality",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << *i.getCardinality ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getName ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.imfug.com/ns/delivery-schema/2018",
          e));

      s << i.getValue ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

